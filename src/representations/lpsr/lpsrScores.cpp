/*
  MusicFormats Library
  Copyright (C) Jacques Menu 2016-2023

  This Source Code Form is subject to the terms of the Mozilla Public
  License, v. 2.0. If a copy of the MPL was not distributed with this
  file, you can obtain one at http://mozilla.org/MPL/2.0/.

  https://github.com/jacques-menu/musicformats
*/

#include "visitor.h"

#include "mfPreprocessorSettings.h"

#include "mfAssert.h"
#include "mfLibraryComponent.h"
#include "mfServices.h"
#include "mfStringsHandling.h"

#include "oahOah.h"
#include "lpsrScores.h"

#include "lpsr2lilypondOah.h"

#include "msrBrowsers.h"

#include "waeHandlers.h"


namespace MusicFormats
{

/*
cautionPath =
#'(
  (moveto 0.25 0)
  (rlineto 0.75 0)
  (rlineto -1.0 -1.5)
  (rlineto 1.25 0)

  (moveto 0.75 1.5)
  (rlineto 1.75 -3.5)
  (rlineto -4.0 0)

  (closepath))
caution =
\markup {
  \path #0.2 #cautionPath
}

goAheadRightArrowPath =
#'(
 ; (moveto 0.25 0)
  (lineto 5.0 0)

  (moveto 5.0 0.0)
  (lineto 4.0 1.125)

  (moveto 5.0 0.0)
  (lineto 4.0 -1.125)

  (closepath))
goAheadRightArrow =
\markup {
  \path #0.2 #goAheadRightArrowPath
}

customBreathe = {
  \once\override BreathingSign.outside-staff-priority = 1
  \once\override BreathingSign.stencil = #ly:text-interface::print
  \once\override BreathingSign.text = ","
  \once\override BreathingSign.font-size = 7
  \once\override BreathingSign.font-series= #'bold
  \breathe
}

*/

//______________________________________________________________________________
S_lpsrScore lpsrScore::create (
  int                 inputLineNumber,
  const S_msrScore&   theMsrScore,
  const S_mfcMultiComponent& multiComponent)
{
  lpsrScore* obj = new lpsrScore (
    inputLineNumber,
    theMsrScore,
    multiComponent);
  assert (obj != nullptr);
  return obj;
}

lpsrScore::lpsrScore (
  int                 inputLineNumber,
  const S_msrScore&   theMsrScore,
  const S_mfcMultiComponent& multiComponent)
    : lpsrElement (inputLineNumber)
{
#ifdef MF_SANITY_CHECKS_ARE_ENABLED
  // sanity check
  mfAssert (
    __FILE__, __LINE__,
    theMsrScore != nullptr,
    "theMsrScore is null");

  mfAssert (
    __FILE__, __LINE__,
    multiComponent != nullptr,
    "multiComponent is null");
#endif // MF_SANITY_CHECKS_ARE_ENABLED

  fEmbeddedMsrScore = theMsrScore;

  fMultiComponent = multiComponent;

  // should the initial comments about the service and the options used
  // be generated?
  if (gGlobalLpsr2lilypondOahGroup->getXml2lyInfos ()) {
    // create the 'generated by' comment
    {
      std::stringstream ss;

      ss <<
        "Generated by " <<
        gOahOahGroup->getOahOahGroupServiceName () <<
        ' ' <<
        getGlobalMusicFormatsVersionNumberAndDate () <<
        std::endl <<

        "% on " <<
        gServiceRunData->getRunDateFull () <<
        std::endl <<

        "% from ";

      std::string inputSourceName =
        gServiceRunData->getInputSourceName ();

      if (inputSourceName == "-") {
        ss << "standard input";
      }
      else {
        ss << "\"" << inputSourceName << "\"";
      }

      fInputSourceNameComment =
        lpsrComment::create (
          inputLineNumber,
          ss.str (),
          lpsrCommentGapAfterwardsKind::kCommentGapAfterwardsYes);
    }

    // create the 'conversion date' comment
    {
      std::stringstream ss;

      ss <<
        "The conversion date was: " <<
        gServiceRunData->getRunDateFull ();

      fRunDateComment =
        lpsrComment::create (
          inputLineNumber,
          ss.str (),
          lpsrCommentGapAfterwardsKind::kCommentGapAfterwardsYes);
    }

    // create the 'conversion command' comments
    S_oahHandler
      currentOahHandler =
        oahHandler::getCurrentOahHandler ();

    std::string
      launchCommandAsSupplied =
        currentOahHandler->
          getLaunchCommandAsSupplied (),

      launchCommandWithLongOptionsNames =
        currentOahHandler->
          getLaunchCommandWithLongOptionsNames (),
      launchCommandWithShortOptionsNames =
        currentOahHandler->
          getLaunchCommandWithShortOptionsNames ();

    Bool
      longAndSuppliedOptionsDiffer =
        launchCommandWithLongOptionsNames
          !=
        launchCommandAsSupplied,
      shortAndSuppliedOptionsDiffer =
        launchCommandWithShortOptionsNames
          !=
        launchCommandAsSupplied;

    // create the 'conversion command as supplied' comment
    {
      std::stringstream ss;

      ss <<
        "The conversion command as supplied was: " <<
        std::endl <<
        "%" <<
        gTab <<
        launchCommandAsSupplied;

      fCommandLineAsSuppliedComment =
        lpsrComment::create (
          inputLineNumber,
          ss.str (),
          longAndSuppliedOptionsDiffer || shortAndSuppliedOptionsDiffer
            ? lpsrCommentGapAfterwardsKind::kCommentGapAfterwardsNo
            : lpsrCommentGapAfterwardsKind::kCommentGapAfterwardsYes);
    }

    // create the 'conversion command with long options names' comment if relevant
    if (longAndSuppliedOptionsDiffer) {
      std::stringstream ss;

      ss <<
        "or, with long option names:" <<
        std::endl <<
        "%" <<
        gTab <<
        launchCommandWithLongOptionsNames;

      fCommandLineLongOptionsComment =
        lpsrComment::create (
          inputLineNumber,
          ss.str (),
          shortAndSuppliedOptionsDiffer
            ? lpsrCommentGapAfterwardsKind::kCommentGapAfterwardsNo
            : lpsrCommentGapAfterwardsKind::kCommentGapAfterwardsYes);
    }

    // create the 'conversion command with short options names' comment if relevant
    if (shortAndSuppliedOptionsDiffer) {
      // create the 'command line short options' comment
      std::stringstream ss;

      ss <<
        "or, with short option names:" <<
        std::endl <<
        "%" <<
        gTab <<
        launchCommandWithShortOptionsNames;

      fCommandLineShortOptionsComment =
        lpsrComment::create (
          inputLineNumber,
          ss.str (),
          lpsrCommentGapAfterwardsKind::kCommentGapAfterwardsYes);
    }
  }

  // initialize Scheme functions informations
  // ----------------------------------------

  if (gGlobalLpsr2lilypondOahGroup->getLilypondRunDate ()) {
    // create the date and time signature functions
    addDateAndTimeSchemeFunctionsToScore ();
  }

  if (gGlobalLpsr2lilypondOahGroup->getPointAndClickOff ()) {
    // create the pointAndClickOff scheme function
    addPointAndClickOffSchemeFunctionsToScore ();
  }

  if (gGlobalLpsr2lilypondOahGroup->getPointAndClickOff ()) {
    // create the glissandoWithText scheme functions
    addGlissandoWithTextSchemeFunctionsToScore ();
  }

  if (gGlobalLpsr2lilypondOahGroup->getAutoVoices ()) {
    // create the auto-voices include command JMI
  }

  if (gGlobalLpsr2lilypondOahGroup->getLilyJazz ()) {
    // create the LilyJazzFont include command JMI
  }

  if (gGlobalLpsr2lilypondOahGroup->getJianpu ()) {
    // create the Jianpu include command JMI
  }

  // create the header
  fScoreHeader =
    lpsrHeader::create (
      inputLineNumber);

  // create the paper
  fScorePaper =
    lpsrPaper::create (
      inputLineNumber,
      fEmbeddedMsrScore->getScaling (),
      fEmbeddedMsrScore->getPageLayout ());

  // populate the paper

  // geometry
//   if (gLpsrOahGroup->getPaperWidthAtom ()->getSelected ()) {
//     fScorePaper->
//       setPaperWidth (
//         gLpsrOahGroup->getPaperWidth ());
//   }
//
//   if (gLpsrOahGroup->getPaperHeightAtom ()->getSelected ()) {
//     fScorePaper->
//       setPaperHeight (
//         gLpsrOahGroup->getPaperHeight ());
//   }
//
//   if (gLpsrOahGroup->getPaperHorizontalShiftAtom ()->getSelected ()) {
//     fScorePaper->
//       setTopMargin (
//         gLpsrOahGroup->getTopMargin ());
//   }
//
//   if (gLpsrOahGroup->getPaperHorizontalShiftAtom ()->getSelected ()) {
//     fScorePaper->
//       setBottomMargin (
//         gLpsrOahGroup->getBottomMargin ());
//   }
//
//   if (gLpsrOahGroup->getPaperHorizontalShiftAtom ()->getSelected ()) {
//     fScorePaper->
//       setLeftMargin (
//         gLpsrOahGroup->getLeftMargin ());
//   }
//
//   if (gLpsrOahGroup->getPaperHorizontalShiftAtom ()->getSelected ()) {
//     fScorePaper->
//       setRightMargin (
//         gLpsrOahGroup->getRightMargin ());
//   }

  // indents
  if (gLpsrOahGroup->getPaperHorizontalShiftAtom ()->getSelected ()) {
    fScorePaper->
      setHorizontalShift (
        msrLength::create (
          gLpsrOahGroup->getPaperHorizontalShift ().getLengthUnitKind (),
          gLpsrOahGroup->getPaperHorizontalShift ().getLengthValue ()));
  }

  if (gLpsrOahGroup->getPaperIndentAtom ()->getSelected ()) {
    fScorePaper->
      setIndent (
        msrLength::create (
          gLpsrOahGroup->getPaperIndent ().getLengthUnitKind (),
          gLpsrOahGroup->getPaperIndent ().getLengthValue ()));
  }

  if (gLpsrOahGroup->getPaperShortIndentAtom ()->getSelected ()) {
    fScorePaper->
      setShortIndent (
        msrLength::create (
          gLpsrOahGroup->getPaperShortIndent ().getLengthUnitKind (),
          gLpsrOahGroup->getPaperShortIndent ().getLengthValue ()));
  }

  // spaces
  if (gLpsrOahGroup->getMarkupSystemSpacingPaddingAtom ()->getSelected ()) {
    fScorePaper->
      setMarkupSystemSpacingPadding (
        msrLength::create (
          gLpsrOahGroup->getMarkupSystemSpacingPadding ().getLengthUnitKind (),
          gLpsrOahGroup->getMarkupSystemSpacingPadding ().getLengthValue ()));
  }

  if (gLpsrOahGroup->getBetweenSystemSpaceAtom ()->getSelected ()) {
    fScorePaper->
      setBetweenSystemSpace (
        msrLength::create (
          gLpsrOahGroup->getBetweenSystemSpace ().getLengthUnitKind (),
          gLpsrOahGroup->getBetweenSystemSpace ().getLengthValue ()));
  }

  if (gLpsrOahGroup->getPageTopSpacingAtom ()->getSelected ()) {
    fScorePaper->
      setPageTopSpacing (
        msrLength::create (
          gLpsrOahGroup->getPageTopSpacing ().getLengthUnitKind (),
          gLpsrOahGroup->getPageTopSpacing ().getLengthValue ()));
  }

  // counts
  if (gLpsrOahGroup->getPageCountAtom ()->getSelected ()) {
    fScorePaper->
      setPageCount (gLpsrOahGroup->getPageCount ());
  }

  if (gLpsrOahGroup->getSystemCountAtom ()->getSelected ()) {
    fScorePaper->
      setSystemCount (gLpsrOahGroup->getSystemCount ());
  }

  // conversion date

  if (gGlobalLpsr2lilypondOahGroup->getLilypondRunDate ()) {
    // define headers and footers

    fScorePaper->
      setOddHeaderMarkup (
R"(\markup {
    \fill-line {
      \unless \on-first-page {
        \fromproperty #'page:page-number-std::string
        ' '
        \fromproperty #'header:title
        ' '
        \fromproperty #'header:subtitle
      }
    }
  }
)"
      );

    fScorePaper->
      setEvenHeaderMarkup (
R"(\markup {
    \fill-line {
      \unless \on-first-page {
        \fromproperty #'page:page-number-std::string
        ' '
        \fromproperty #'header:title
        ' '
        \fromproperty #'header:subtitle
      }
    }
  }
)"
      );

    std::stringstream ss;

/* JMI YES???
      \fill-line {
        "https://github.com/jacques-menu/musicformats - http://www.lilypond.org"
      }
*/
    ss <<
R"(\markup {
    \tiny
    \column {
      \fill-line {
        #(string-append
)"
      <<
      "\"Score generated from MusicXML data by " <<
      gOahOahGroup->getOahOahGroupServiceName () <<
      ' ' <<
      getGlobalMusicFormatsVersionNumberAndDate () <<
      " and LilyPond \" (lilypond-version))" <<
R"(
      }
      \fill-line { \column { \italic { \concat { \filen " - " \modTimeAsString } } } }
    }
  }
)";

    fScorePaper->
      setOddFooterMarkup (
        ss.str ());
  }

  // create the score layout
  if (! gGlobalLpsr2lilypondOahGroup->getNoTopLevelLayoutBlock ()) {
    fScoreLayout =
      lpsrLayout::create (
        inputLineNumber);
  }
}

lpsrScore::~lpsrScore ()
{}

void lpsrScore::setLilyJazzFontFileIncludeIsNeeded ()
{
  if (! fLilyJazzFontFileIncludeIsNeeded) {
    addLilyJazzFontFileIncludeToScore ();

    fLilyJazzFontFileIncludeIsNeeded = true;
  }
}

void lpsrScore::addLilyJazzFontFileIncludeToScore ()
{
  std::string
    schemeModulesName =
      "LilyJazz font include file",

    schemeModulesDescription =
R"(
% The definitions needed to produce scores using the LilyJazz font.
)",

    schemeModulesCode =
R"(
% From https://github.com/OpenLilyPondFonts/lilyjazz
\include "lilyjazz.ily"
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Including LilyJazz definition file '" << schemeModulesName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeModulesName,
        schemeModulesDescription,
        schemeModulesCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeModulesName] =
    schemeFunction;
}

void lpsrScore::setJianpuFileIncludeIsNeeded ()
{
  if (! fJianpuFileIncludeIsNeeded) {
    addJianpuFileIncludeToScore ();

    fJianpuFileIncludeIsNeeded = true;
  }
}

void lpsrScore::addJianpuFileIncludeToScore ()
{
  std::string
    schemeModulesName =
      "jianpu include file",

    schemeModulesDescription =
R"(
% The definitions needed to produce jianpu scores.
)",

    schemeModulesCode =
R"(
% From https://github.com/nybbs2003/lilypond-Jianpu
\include "jianpu10a.ly"
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Including Jianpu definition file '" << schemeModulesName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeModulesName,
        schemeModulesDescription,
        schemeModulesCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeModulesName] =
    schemeFunction;
}

void lpsrScore::setScmAndAccregSchemeModulesAreNeeded ()
{
  if (! fScmAndAccregSchemeModulesAreNeeded) {
    // JMI v0.9.67 addAccordionRegistrationSchemeModulesToScore (); // JMI

    fScmAndAccregSchemeModulesAreNeeded = true;
  }
}

void lpsrScore::addAccordionRegistrationSchemeModulesToScore ()
{
  std::string
    schemeModulesName =
      "scm & accreg",

    schemeModulesDescription =
R"(
% Two modules are to be used in the right order to use accordion registration.
)",

    schemeModulesCode =
R"(
#(use-modules (scm accreg))
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Using Scheme modules '" << schemeModulesName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeModulesName,
        schemeModulesDescription,
        schemeModulesCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeModulesName] =
    schemeFunction;
}

void lpsrScore::setCustomShortBarLineSchemeFunctionIsNeeded ()
{
  if (! fCustomShortBarLineSchemeFunctionIsNeeded) {
    addCustomShortBarLineSchemeFunctionToScore ();

    fCustomShortBarLineSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addCustomShortBarLineSchemeFunctionToScore ()
{
  std::string
    schemeModulesName =
      "custom short barLine Scheme function",

    schemeModulesDescription =
R"(
% The function needed to produce custom short barLines.
)",

    schemeModulesCode =
R"(
#(define ((make-custom-short-bar-line x y) grob extent)
   "Draw a short bar line."
   (let* ((short-staff (* 1/2 (ly:staff-symbol-staff-space grob)))
          (staff-line-thickness (ly:staff-symbol-line-thickness grob))
          (height (interval-end extent)))
     (bar-line::draw-filled-box
      (cons 0 (+ x staff-line-thickness))
      (cons (- height (* 7 short-staff) x) (- height short-staff x))
      staff-line-thickness
      extent
      grob)))

#(add-bar-glyph-print-procedure '/' (make-custom-short-bar-line 0.1 0.1))

#(define-bar-line '/' '/' #f #f)
)";


#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Including Jianpu definition file '" << schemeModulesName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeModulesName,
        schemeModulesDescription,
        schemeModulesCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeModulesName] =
    schemeFunction;
}

void lpsrScore::setTongueSchemeFunctionIsNeeded ()
{
  if (! fTongueSchemeFunctionIsNeeded) {
    addTongueSchemeFunctionToScore ();

    fTongueSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addTongueSchemeFunctionToScore ()
{
  std::string
    schemeFunctionName =
      "tongue",

    schemeFunctionDescription =
R"(
% Creates multiple tongue technicals, argument is a number.
% Example: 'c4 -\tongue #3' creates a triple tongue.
)",

    schemeFunctionCode =
R"(
tongue =
#(define-music-function (parser location dots) (integer?)
   (let ((script (make-music 'ArticulationEvent
                   'articulation-type "staccato")))
     (set! (ly:music-property script 'tweaks)
           (acons 'stencil
             (lambda (grob)
               (let ((stil (ly:script-interface::print grob)))
                 (let loop ((count (1- dots)) (new-stil stil))
                   (if (> count 0)
                       (loop (1- count)
                         (ly:stencil-combine-at-edge new-stil X RIGHT stil 0.2))
                       (ly:stencil-aligned-to new-stil X CENTER)))))
             (ly:music-property script 'tweaks)))
     script))
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setEditorialAccidentalSchemeFunctionIsNeeded ()
{
  if (! fEditorialAccidentalSchemeFunctionIsNeeded) {
    addEditorialAccidentalSchemeFunctionToScore ();

    fEditorialAccidentalSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addEditorialAccidentalSchemeFunctionToScore ()
{
  std::string
    schemeFunctionName =
      "editorialAccidental",

    schemeFunctionDescription =
R"(
% Craetes editorial accidentals as LilyPond musica ficta.
% Example: '\editorialAccidental cis4'.
)",

    schemeFunctionCode =
R"(
editorialAccidental =
#(define-music-function
  (note)
  (ly:music?)
  #{
    \once\accidentalStyle forget
    \once\set suggestAccidentals = ##t
    #note
  #})
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setDynamicsSchemeFunctionIsNeeded ()
{
  if (! fDynamicsSchemeFunctionIsNeeded) {
    addDynamicsSchemeFunctionToScore ();

    fDynamicsSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addDynamicsSchemeFunctionToScore ()
{
  std::string
    schemeFunctionName =
      "dynamics",

    schemeFunctionDescription =
R"(
% Creates variables define dynamics not native to LilyPond.
)",

    schemeFunctionCode =
R"(
rf = #(make-dynamic-script "rf")
sfpp = #(make-dynamic-script "sfpp")
sffz = #(make-dynamic-script "sffz")
ppppp = #(make-dynamic-script "ppppp")
pppppp = #(make-dynamic-script "pppppp")
fffff = #(make-dynamic-script "fffff")
ffffff = #(make-dynamic-script "ffffff")
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setTupletsCurvedBracketsSchemeFunctionIsNeeded ()
{
  if (! fTupletsCurvedBracketsSchemeFunctionIsNeeded) {
    addTupletsCurvedBracketsSchemeFunctionToScore ();

    fTupletsCurvedBracketsSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addTupletsCurvedBracketsSchemeFunctionToScore ()
{
  std::string
    schemeFunctionName =
      "tupletsCurvedBrackets",

    schemeFunctionDescription =
R"(
% A function to draw curved tuplets brackets, not native to LilyPond.
% Thanks to Ben, mailto:soundsfromsound@gmail.com
)",

    schemeFunctionCode =
R"(
tupletsCurvedBrackets = {
  % Use slur-stencil
  \override TupletBracket.stencil = #ly:slur::print
  %% Use 'thickness from Slur
  \override TupletBracket.thickness = #1.2
  %% 'control-points need to be set
  \override TupletBracket.control-points =
  #(lambda (grob)
     (let* ((x-pos (ly:grob-property grob 'X-positions))
            (pos (ly:grob-property grob 'positions))
            (x-ln (interval-length x-pos))
            (dir (ly:grob-property grob 'direction))
            ; read out the height of the TupletBracket, may be
            ; negative!
            (height (- (cdr pos) (car pos)))
            ; height-corr is introduced because sometimes the shape
            ; of the slur needs to be adjusted.
            ; It is used in the 2nd/3rd control-point.
            ; The value of 0.3 is found by trial and error
            (height-corr (* 0.3 dir height))
            (edge-height (ly:grob-property grob 'edge-height
                           '(0.7 . 0.7)))
            (pad 1.0))
       (list
        ; first cp
        (cons
         (+ (car x-pos) 0.5)
         (- (+ (* dir pad) (+ (car pos) (* -1 dir
                                          (car edge-height))))
           (if (= dir -1)
               (if (> height 3)
                   (/ dir 2.0)
                   0.0)
               (if (< height -3)
                   (/ dir 2.0)
                   0.0))))
        ; second cp
        (cons
         (+ (car x-pos) (* x-ln 1/4))
         (+ (* dir pad) (+ (car pos) (* dir (+ 0.5 height-corr)))))
        ; third cp
        (cons
         (+ (car x-pos) (* x-ln 3/4))
         (+ (* dir pad) (+ (cdr pos) (* dir (- 0.5 height-corr)))))
        ; fourth cp
        (cons
         (- (cdr x-pos) 0.5)
         (+ (* dir pad) (+ (cdr pos) (* -1 dir (cdr edge-height)))))
        )))
  \override TupletBracket.staff-padding = #' ()
  #(define (invert-direction x) (if (eq? UP
                                         (ly:tuplet-bracket::calc-direction x)) DOWN UP))
  % \override TupletBracket.direction = #invert-direction
}
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setAfterSchemeFunctionIsNeeded ()
{
  if (! fAfterSchemeFunctionIsNeeded) {
    addAfterSchemeFunctionToScore ();

    fAfterSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addAfterSchemeFunctionToScore ()
{
  std::string
    schemeFunctionName =
      "after",

    schemeFunctionDescription =
R"(
% A function to create events after given music.
% Thanks to David Kastrup for the inspiration!
)",

    schemeFunctionCode =
R"(
after =
#(define-music-function (t e m) (ly:duration? ly:music? ly:music?)
   #{
     \context Bottom <<
       #m
       { \skip $t <> -\tweak extra-spacing-width #empty-interval $e }
     >>
   #})
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setTempoNotesRelationshipSchemeFunctionIsNeeded ()
{
  if (! fTempoNotesRelationshipSchemeFunctionIsNeeded) {
    addTempoNotesRelationshipSchemeFunctionToScore ();

    fTempoNotesRelationshipSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addTempoNotesRelationshipSchemeFunctionToScore ()
{
  std::string
    schemeFunctionName =
      "tempoNotesRelationship",

    schemeFunctionDescription =
R"(
% A function to create tempo relationships,
% such as 'b8 [ b8 ]' = '\tuplet 3/2 { b4 b8 }' for swing.
% See http://lsr.di.unimi.it/LSR/Item?id=204
)",

    schemeFunctionCode =
      // add ! before ( and after ) since the code contains )"
R"!(
tempoNotesRelationshipStaffReduce = #-3

tempoNotesRelationship =
#(define-music-function (parser location label parenthesized musicI musicII)
   (string? boolean? ly:music? ly:music?)
   (let* (
           (left-paren (if parenthesized "(" ""))
           (right-paren (if parenthesized ")" ""))
           )
     #{
       \tempo \markup {
         \line \general-align #Y #DOWN {
           % 1st column in line
           $label

           % 2nd column in line

           $left-paren

           \score {
             \new Staff \with {
               % reduce the font size a la cue
               fontSize = #tempoNotesRelationshipStaffReduce
               \override StaffSymbol.staff-space = #(magstep tempoNotesRelationshipStaffReduce)
               % hide the staff lines
               \override StaffSymbol.line-count = #0
               % align horizontally
               \override VerticalAxisGroup.Y-extent = #'(-0.85 . 0)
             }

             {
               % \override Score.SpacingSpanner.common-shortest-duration = #(ly:make-moment 1/2) % super-tight
               % \override Score.SpacingSpanner.common-shortest-duration = #(ly:make-moment 1/4) % tight
               % \override Score.SpacingSpanner.common-shortest-duration = #(ly:make-moment 3/16) % even
               \override Score.SpacingSpanner.common-shortest-duration = #(ly:make-moment 5/32) % even

               % the left music
               \relative c' { \stemUp $musicI }

               % the equivalence sign
               \once \override Score.TextScript.Y-offset = #-0.4
               s4.^\markup{
                 \halign #-1 "="
               }

               % the right music
               \relative c' { \stemUp $musicII }
             }

             \layout {
               indent = 0
               \context {
                 \Staff
                 \remove "Clef_engraver"
                 \remove "Time_signature_engraver"
               }
             } % layout end
           } % score end

           $right-paren

         } % line end
       } % markup end
     #}))
)!";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setGlissandoWithTextSchemeFunctionsIsNeeded ()
{
  if (! fGlissandoWithTextSchemeFunctionsIsNeeded) {
    addGlissandoWithTextSchemeFunctionsToScore ();

    fGlissandoWithTextSchemeFunctionsIsNeeded = true;
  }
}

void lpsrScore::addGlissandoWithTextSchemeFunctionsToScore ()
{
  std::string
    schemeFunctionName =
      "glissandoWithText",

    schemeFunctionDescription =
R"(
% \\glissandoTextOn/Off to get text along glissandos.
)",

    schemeFunctionCode =
R"(
% thanks to Thomas Morley for contributing this code

%% c/p from lily-library.scm (it is not public)
#(define (sign x)
  (if (= x 0)
      0
      (if (< x 0) -1 1)))

#(define (radians->degree radians)
  (/ (* radians 180) PI))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Glissando with text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Reads from Glissando.details
%%%%   - glissando-text
%%%%   - glissando-text-font-size
%%%%   - glissando-text-padding

#(define* ((gliss-plus-text #:optional always-add-text) grob)
  (let*  ((orig-grob (ly:grob-original grob))
          (broken-beams (ly:spanner-broken-into orig-grob))
          (stil (ly:line-spanner::print grob)))
    (if (or (null? broken-beams)
            (and (pair? broken-beams)
                 (or
                    always-add-text
                    (equal? grob (car broken-beams)))))
        (if (not (ly:stencil? stil))
            #f
            (let* ((layout (ly:grob-layout grob))
                   (line-thickness
                     (ly:output-def-lookup layout 'line-thickness))
                   (props
                     (ly:grob-alist-chain
                       grob
                       (ly:output-def-lookup layout 'text-font-defaults)))
                   (font
                     (ly:paper-get-font
                     layout
                     (cons
                       '((font-encoding . fetaMusic) (font-name . #f))
                       props)))
                   (trill-glyph
                     (ly:font-get-glyph font "scripts.trill_element"))
                   (trill-glyph-height
                     (interval-length (ly:stencil-extent trill-glyph Y)))
                   (zigzag-width
                     (ly:grob-property grob 'zigzag-width))
                   (thickness (ly:grob-property grob 'thickness))
                   (thick
                     (if (number? thickness)
                         (/ thickness 10)
                         line-thickness))
                   (style (ly:grob-property grob 'style))
                   (corr
                     (cond ((eq? style 'trill)
                             trill-glyph-height)
                           ((eq? style 'zigzag)
                             (+ thick zigzag-width))
                           (else 0)))
                   (stil-x-ext (ly:stencil-extent stil X))
                   (stil-y-ext (ly:stencil-extent stil Y))
                   (stil-x-length (- (cdr stil-x-ext) (car stil-x-ext)))
                   (stil-y-length (- (cdr stil-y-ext) (car stil-y-ext)))
                   (details (ly:grob-property grob 'details))
                   (gliss-text
                     (assoc-get 'glissando-text details "gliss."))
                   (gliss-text-font-size
                     (assoc-get 'glissando-text-font-size details -5))
                   (gliss-text-padding
                     (assoc-get 'glissando-text-padding details 0.5))
                   (left-bound-info (ly:grob-property grob 'left-bound-info))
                   (y-left (assoc-get 'Y left-bound-info))
                   (right-bound-info (ly:grob-property grob 'right-bound-info))
                   (y-right (assoc-get 'Y right-bound-info))
                   (slant (sign (- y-right y-left)))
                   (gradient
                     (/ (- stil-y-length corr) stil-x-length))
                   ; `ly:stencil-rotate' needs an angle in degrees...
                   ; TODO use ly:angle ?
                   (alpha
                     (radians->degree
                       (angle
                         (make-rectangular
                           stil-x-length
                           (- stil-y-length corr line-thickness)))))
                   (text-stencil
                     (grob-interpret-markup
                       grob
                         (make-halign-markup CENTER
                           (make-fontsize-markup
                             gliss-text-font-size
                             gliss-text))))
                   (text-stencil-height
                     (interval-length (ly:stencil-extent text-stencil Y)))
                   (y-move
                     (+
                       (/ text-stencil-height 2)
                       gliss-text-padding))
                   (rotated-text-stil
                     (ly:stencil-rotate text-stencil (* slant alpha) 0 0))
                   (text-center-X
                     (interval-center (ly:stencil-extent rotated-text-stil X)))
                   (translated-text-stencil
                     (ly:stencil-translate
                       rotated-text-stil
                       ; Constuction-helpers
                       ;text-stencil
                       ;(make-cross-stencil '(0 . 0)) ; not included atm
                       (cons
                         (+
                           (car stil-x-ext)
                           (/ stil-x-length 2)
                           (* slant -1 y-move gradient))
                         (+
                           (car stil-y-ext)
                           (/ stil-y-length 2)
                           y-move)))))
            (ly:stencil-add
              stil
              ; Construction-helpers
              ;
              ;(make-line-stencil
              ;  0.1
              ;  (+ (car stil-x-ext)(/ stil-x-length 2))
              ;  (+ (car stil-y-ext)(/ stil-y-length 2))
              ;  (+ (car stil-x-ext)(/ stil-x-length 2)(* slant -1 10 gradient))
              ;  10)
              ;
              ; (2) colors the text-part
              ;
              ;(stencil-with-color translated-text-stencil red)
              translated-text-stencil
              )))
        stil)))

glissandoTextOn =
  \temporary \override Glissando.stencil =
    #(gliss-plus-text
      ; change to true, if added text is wished for both parts of a broken
      ; glissando
      ; TODO added text at second parts needs to be improved, vertical
      ; positioning is sometimes bad
      #f)

glissandoTextOff = \revert Glissando.stencil
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme functions for '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setOtherDynamicSchemeFunctionIsNeeded ()
{
  if (! fOtherDynamicSchemeFunctionIsNeeded) {
    addOtherDynamicSchemeFunctionToScore ();

    fOtherDynamicSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addOtherDynamicSchemeFunctionToScore ()
{
  std::string
    schemeFunctionName =
      "otherDynamic",

    schemeFunctionDescription =
R"(
% \\otherDynamic to handle any string as a dynamic.
)",

    schemeFunctionCode =
R"(
#(use-modules (ice-9 regex))

otherDynamic =
#(define-event-function (parser location text) (markup?)
   (if (string? text)
       (let* ((underscores-replaced
               (string-map
                (lambda (x) (if (eq? x #\_) #\space x))
                text))
              (split-text (string-split underscores-replaced #\space))
              (formatted (map
                          (lambda (word)
                            (if (string-match "^[mrzfps]*$" word)
                                (markup #:dynamic word)
                                (markup #:normal-text #:italic word)))
                          split-text)))
         #{
           #(make-dynamic-script (make-line-markup formatted))
         #})
       ; user provided a full-blown markup, so we don't mess with it:
       #{
         #(make-dynamic-script (markup #:normal-text text))
       #}))
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme functions for '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setAutoVoicesSchemeFunctionIsNeeded ()
{
  if (! fAutoVoicesSchemeFunctionIsNeeded) {
    addAutoVoicesSchemeFunctionToScore ();

    fAutoVoicesSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addAutoVoicesSchemeFunctionToScore ()
{
  std::string
    schemeFunctionName =
      "autoVoices",

    schemeFunctionDescription =
R"(
% \\autoVoices to handle rests (experimental).
)",

    schemeFunctionCode =
R"(
%{
  Thanks to jean@abou-samra.fr

  Engraver to emulate \voiceOne, \voiceTwo, etc. and \oneVoice inserted
  automatically based on the number of voices.  In other words, as soon
  as there is only one voice, \voiceOne is applied.  Else, nothing is done,
  meaning that the manual setting applies.  Thus, you should put \voiceOne,
  \voiceTwo, etc. just once at the beginning of every voice.
  This is tailored  to the workflow of xml2ly.
%}


#(define-macro (prepend! elt lst)
   "Convenience macro to prepend ``elt`` in front of ``lst``.

This translates into a ``set!``, so the main advantage is that this
works with procedures that have setters, like ``ly:context-property``
et al."
   `(set! ,lst (cons ,elt ,lst)))


% Apparently forgotten in scm/define-music-functions.scm...
#(define-public ly:event-property
   (make-procedure-with-setter ly:event-property
                               ly:event-set-property!))


% Versions of \voiceOne, etc. that set a property
% in their context, telling the voice number.  Here's
% why this is needed.  The engraver works by doing overrides
% corresponding to \oneVoice in voices that are playing alone.
% Events come in a certain order, and in the only place where
% we could process all of them at once, namely the
% process-music slot, it is too late to do the overrides
% because other engravers may have already processed the
% music and created grobs.  So, every time we notice an
% event, we apply \oneVoice if it is found to be alone.
% When we later hear another event, we have to revert
% that setting by applying \voiceOne or such.

#(set-oect-property! 'globalVoiceNumber 'translation-type? integer?)



#(define (make-self-telling-voice-props-set n)
   (make-sequential-music
     (list
       (make-property-set 'globalVoiceNumber n)
       (make-voice-props-set n))))


voiceOne = #(make-self-telling-voice-props-set 0)
voiceTwo = #(make-self-telling-voice-props-set 1)
voiceThree = #(make-self-telling-voice-props-set 2)
voiceFour = #(make-self-telling-voice-props-set 3)


#(define (apply-voice-props-set n context)
   ;(ly:message "Applying set for voice ~s; context: ~s"
   ;            n
   ;            context)
   (let ((props-set (if n
                        ; Use the default function here, there is no
                        ; need to set the voice number.
                        (make-voice-props-set n)
                        (make-voice-props-revert))))
     (for-some-music
       (lambda (music)
         (define (get . args)
           (apply ly:music-property music args))
         ; No event class   specific to PropertySet?
         (case (ly:music-property music 'name)
           ((PropertySet)
            (ly:context-set-property! context
                                      (get 'symbol)
                                      (get 'value)))
           ((PropertyUnset)
            (ly:context-unset-property context
                                       (get 'symbol)))
           ((OverrideProperty)
            ; pop-first is always true in \voiceOne and such.
            (ly:context-pushpop-property context
                                         (get 'symbol)
                                         (get 'grob-property))
            (ly:context-pushpop-property context
                                         (get 'symbol)
                                         (get 'grob-property)
                                         (get 'grob-value)))
           ((RevertProperty)
            ;(ly:message "Reverting ~s ~s"
            ;            (get 'symbol)
            ;            (get 'grob-property))
            (ly:context-pushpop-property context
                                         (get 'symbol)
                                         (get 'grob-property))
            ;(ly:message "Became ~s"
            ;            (ly:context-grob-definition context (get 'symbol)))
            )
           (else
             ; Recurse.
             #f)))
       (ly:music-deep-copy props-set))))

% Maintained on Staff level, to decide whether to change
% grob directions at a given point.
#(set-oect-property! 'busyEvents 'translation-type? list?)

% Nonexistent?
#(define (event-is-of-type? event type)
   (memq type (ly:event-property event 'class)))

#(define (event-origin-voice event)
   (ly:event-property event 'origin-voice))

#(define (event-origin-voice-number event)
   (ly:context-property
     (event-origin-voice event)
     'globalVoiceNumber))

% This is in a way similar to the action of the
% Grob_pq_engraver -- operating on events instead
% of grobs.
#(define (process-event! context event)
   ; Ignore contexts where none of \voiceOne, \voiceTwo, etc.
   ; is used.
   (if (not (null? (ly:context-property context 'globalVoiceNumber)))
       (let ((staff (ly:context-find context 'Staff)))
             ; The whole point of the engraver is to exclude skips!
             (if (not (event-is-of-type? event 'skip-event))
                 (begin
                   ;(ly:message "Adding an event originating from music type ~s"
                   ;            (ly:music-property
                   ;              (ly:event-property event 'music-cause)
                   ;              'name))
                   (ly:event-set-property! event
                                           'origin-voice
                                           context)
                   (ly:event-set-property! event
                                           'origin-moment
                                           (ly:context-current-moment context))
                   (prepend! event (ly:context-property staff 'busyEvents))
                   (let* ((busy-events (ly:context-property staff 'busyEvents))
                          (busy-voices
                            (map event-origin-voice-number busy-events))
                          (unique-busy-voices (uniq-list (sort busy-voices <)))
                          (one-voice (eqv? 1 (length unique-busy-voices))))
                     ;(ly:message "Formatting pass, unique busy voices: ~s"
                     ;            unique-busy-voices)
                     (for-each
                       (lambda (event)
                         (let ((origin-voice (event-origin-voice event))
                               (new-voice-number (if one-voice
                                                     #f
                                                     (event-origin-voice-number event))))
                         (apply-voice-props-set new-voice-number origin-voice)))
                       busy-events)))))))


#(define (prune-events! context)
   (let ((current-moment (ly:context-current-moment context)))
     (ly:context-set-property!
       context
       'busyEvents
       (filter
         (lambda (event)
           (let* ((origin-moment (ly:event-property event 'origin-moment))
                  ; Hack... No better way?
                  (music-cause (ly:event-property event 'music-cause))
                  (event-length (ly:music-length music-cause))
                  (sum (ly:moment-add origin-moment event-length)))
           ;(ly:message "Type: ~s Current moment: ~s  origin: ~s  length: ~s  result: ~s"
           ;            (ly:music-property music-cause 'name)
           ;            current-moment
           ;            origin-moment
           ;            event-length
           ;            (ly:moment<? current-moment sum))

           (ly:moment<? current-moment sum)))

         (ly:context-property context 'busyEvents)))))


#(define (Auto_voices_engraver context)
   (make-engraver
     (listeners
       ((rhythmic-event engraver event)
          (process-event! context event)))
     ((process-music engraver)
        ;(ly:message "Done in this time step")
        #f)))

#(define (Prune_busy_events_engraver context)
   (make-engraver
     ((start-translation-timestep engraver)
        (prune-events! context))))


\layout {
  \context {
    \Voice
    \consists #Auto_voices_engraver
  }
  \context {
    \Staff
    \consists #Prune_busy_events_engraver
  }
}
)";
}

void lpsrScore::setSchleiferSchemeFunctionIsNeeded ()
{
  if (! fSchleiferSchemeFunctionIsNeeded) {
    addSchleiferSchemeFunctionToScore ();

    fSchleiferSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addSchleiferSchemeFunctionToScore ()
{
  std::string
    schemeFunctionName =
      "schleifer",

    schemeFunctionDescription =
R"(
% \\schleifer.
)",

    schemeFunctionCode =
R"(
%% http://lsr.di.unimi.it/LSR/Item?id=720
%% see also http://lilypond.org/doc/v2.18/Documentation/notation/graphic

%LSR contributed by Valentin as per request http://code.google.com/p/lilypond/issues/detail?id=503

% schleifer: slide, coulé

schleifer =
#(define-music-function (parser location start) (ly:music?)
   #{\once \override Slur $'direction = #UP
     \once \override Slur $'stencil = $(lambda (grob)
                                         (let* ((slur-stencil (ly:slur::print grob))
                                                (Y-ext (ly:stencil-extent slur-stencil Y))
                                                (text-stencil (ly:text-interface::print grob))
                                                (prall-stencil (ly:stencil-translate text-stencil
                                                                                     (cons 2.5 (car Y-ext))))
                                                (combo-stencil (ly:stencil-combine-at-edge
                                                                prall-stencil X RIGHT
                                                                slur-stencil 0))
                                                (combo-X-ext (ly:stencil-extent combo-stencil X)))
                                           (ly:stencil-translate combo-stencil (cons 0 -1))))
     \once \override Slur.positions = #'(-1 . 2)
     \once \override Slur.text = \markup {
       \musicglyph #"scripts.prall"
     }
     \once \override Slur $'control-points = $(lambda (grob)
                                                (let* ((coords (ly:slur::calc-control-points grob))
                                                       (point-0 (list-ref coords 0))
                                                       (point-1 (list-ref coords 1))
                                                       (point-2 (list-ref coords 2))
                                                       (point-3 (list-ref coords 3)))
                                                  (set-car! point-0 (+ (car point-0) 2))
                                                  (set-car! point-1 (+ (car point-1) 1.5))
                                                  (set-car! point-2 (+ (car point-2) -1))
                                                  (set-car! point-3 (+ (car point-3) -1))
                                                  coords))
     s1*0( $start
     \once \override Rest.transparent = ##t
     \once \override Rest.X-extent = #'(0 . 5)
     \grace r1
     s1*0)
   #}
 )
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme functions for '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setScoopSchemeFunctionIsNeeded ()
{
  if (! fScoopSchemeFunctionIsNeeded) {
    addScoopSchemeFunctionToScore ();

    fScoopSchemeFunctionIsNeeded = true;
  }
}

void lpsrScore::addScoopSchemeFunctionToScore ()
{
  // JMI v0.9.67, check that scoops are up or down?
  std::string
    schemeFunctionName =
      "scoop_stencils",

    schemeFunctionDescription =
R"(
% \\scoopAbove, \\scoopBelow.
)",

    schemeFunctionCode =
R"(
% scoop stencils, thanks to vgay@vintherine.org

#(define (scoop-above-stencil grob)
   (ly:stencil-add
    (ly:note-head::print grob)
    (grob-interpret-markup grob
                           (markup #:with-dimensions '(0 . 0) '(0 . 0)
                                   #:translate '(-0.2 . -0.5)
                                   #:path 0.25 '((moveto -0.2 0.5)
                                                 (curveto 0.2 2 -1.2 2.5 -1.7 2.5))))))
scoopAbove = \once \override NoteHead #'stencil = #scoop-above-stencil

#(define (scoop-below-stencil grob)
   (ly:stencil-add
    (ly:note-head::print grob)
    (grob-interpret-markup grob
                           (markup #:with-dimensions '(0 . 0) '(0 . 0)
                                   #:translate '(-0.2 . -0.5)
                                   #:path 0.25 '((moveto 0 0)
                                                 (curveto 0.2 -1 -1.2 -1.5 -1.7 -1.5))))))
scoopBelow = \once \override NoteHead #'stencil = #scoop-below-stencil

%\relative c'' {
%  \scoopAbove c2 \scoopBelow c2
%}
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme functions for '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setDampMarkupIsNeeded ()
{
  if (! fDampMarkupIsNeeded) {
    addDampMarkupToScore ();

    fDampMarkupIsNeeded = true;
  }
}

void lpsrScore::addDampMarkupToScore ()
{
  std::string
    schemeFunctionName =
      "dampMarkup",

    schemeFunctionDescription =
R"(
% A function to create damp markups,
)",

    schemeFunctionCode =
      // add ! before ( and after ) since the code contains )"
R"!(
damp = \markup {
%  \scale #'(5 . 5)
  {
    \center-column {
      {
        \override #'(thickness . 1.8)
        \combine \draw-line #'(-1.5 . 0)
        \combine \draw-line #'(0 . -1.5)
        \combine \draw-line #'(0 . 1.5)
        \combine \draw-line #'(1.5 . 0)
        \draw-circle #0.8 #0.2 ##f
      }
    }
  }

}
)!";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setDampAllMarkupIsNeeded ()
{
  if (! fDampAllMarkupIsNeeded) {
    addDampAllMarkupToScore ();

    fDampAllMarkupIsNeeded = true;
  }
}

void lpsrScore::addDampAllMarkupToScore ()
{
  std::string
    schemeFunctionName =
      "dampAllMarkup",

    schemeFunctionDescription =
R"(
% A function to create damp all markups,
)",

    schemeFunctionCode =
      // add ! before ( and after ) since the code contains )"
R"!(
dampAll = \markup
%% do not use 'fontsize
%\scale #'(5 . 5)
{
  \combine \bold "O"
  \path #0.2
  #'((moveto -.4 .8)(lineto 2.2 .8)
      (closepath)
      (moveto .9 -.5)(lineto .9 2.1))
}
)!";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setWhiteNoteHeadsIsNeeded ()
{
  if (! fWhiteNoteHeadsIsNeeded) {
    addWhiteNoteHeadsToScore ();

    fWhiteNoteHeadsIsNeeded = true;
  }
}

void lpsrScore::addWhiteNoteHeadsToScore ()
{
  std::string
    schemeFunctionName =
      "whiteNoteHeads",

    schemeFunctionDescription =
R"(
% A function to display note shorter than a quarter with white heads,
% as in some ancient music scores
)",

    schemeFunctionCode =
      // add ! before ( and after ) since the code contains )"
R"!(
whiteNoteHeads =
#(define-music-function (music) (ly:music?)
   #{
     \temporary \override NoteHead.stencil = #ly:text-interface::print
     \temporary \override NoteHead.text = \markup {
       \musicglyph "noteheads.s1"
     }
     \omit \time 3/4
     \shiftNotesDurations #1 #0 { #music }
     \omit \time 3/2
     \revert NoteHead.stencil
     \revert NoteHead.text
   #}
   )
)!";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setBoxAroundNextBarNumberIsNeeded ()
{
  if (! fBoxAroundNextBarNumberIsNeeded) {
    addBoxAroundNextBarNumberToScore ();

    fBoxAroundNextBarNumberIsNeeded = true;
  }
}

void lpsrScore::addBoxAroundNextBarNumberToScore ()
{
  std::string
    schemeFunctionName =
      "boxAroundNextBarNumber",

    schemeFunctionDescription =
R"(
% A macro to draw a box round the next bar number
)",

    schemeFunctionCode =
      // add ! before ( and after ) since the code contains )"
R"!(
boxAroundNextBarNumber = {
  % Prevent bar numbers at the end of a line
  \once\override Score.BarNumber.break-visibility = #end-of-line-invisible

  \once\override Score.BarNumber.font-size = 2
  \once\override Score.BarNumber.stencil =
  #(make-stencil-boxer 0.25 0.5 ly:text-interface::print)
}
)!";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setJazzChordsDisplayIsNeeded ()
{
  if (! fJazzChordsDisplayIsNeeded) {
    addJazzChordsDisplayToScore ();

    fJazzChordsDisplayIsNeeded = true;
  }
}

void lpsrScore::addJazzChordsDisplayToScore ()
{
  std::stringstream ss;

  ss <<
R"###(% std::exception music is chords with markups
#(define (lower-extension pitch chbass)
   "Return lowered markup for pitch note name."
   #{
     \markup \raise #-1.9 \halign #0.2
     #(note-name->markup pitch chbass)
   #})

chExceptionMusic = {)###" <<
  std::endl;

    if (gGlobalLpsr2lilypondOahGroup->getJazzChordsDisplay ()) {
      ss <<
        gGlobalLpsr2lilypondOahGroup->getJazzChordsDisplayLilypondCode ();
    }

  const std::list<std::pair<std::string, std::string>>&
    chordsDisplayList =
      gGlobalLpsr2lilypondOahGroup->getChordsDisplayList ();

  if (chordsDisplayList.size ()) {
    std::list<std::pair<std::string, std::string>>::const_iterator
      iBegin = chordsDisplayList.begin (),
      iEnd   = chordsDisplayList.end (),
      i      = iBegin;

    for ( ; ; ) {
      ss <<
        gTab <<
        (*i).first <<
        "1-\\markup { " <<
        (*i).second <<
        " }" <<
        std::endl;
      if (++i == iEnd) break;
  //     ss << std::endl;
    } // for
  }

  ss <<
    '}' <<
    std::endl << std::endl <<
R"###(% Convert music to list and prepend to existing exceptions.
chExceptions = #( append
                  ( sequential-music-to-chord-exceptions chExceptionMusic #t)
                  ignatzekExceptions))###" <<
    std::endl << std::endl;

  std::string
    schemeFunctionName =
      "jazzChordsDisplay",

  schemeFunctionDescription =
R"(
% A function to display the chords in a common Jazz way using \chordmode
)",

  schemeFunctionCode = ss.str ();

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setColoredLedgerLinesIsNeeded ()
{
  if (! fColoredLedgerLinesIsNeeded) {
    addColoredLedgerLinesToScore ();

    fColoredLedgerLinesIsNeeded = true;
  }
}

void lpsrScore::addColoredLedgerLinesToScore ()
{
  std::stringstream ss;

  ss <<
R"###(% there is ony one ledger line spanner/grob/stencil
% produced for each musical system on the page (!)
% see: ledger-line-spanner.cpp for c++ code for ly:ledger-line-spanner::print

#(define (MyLedgerLineSpannerPrint grob)
   (let*
    ((stil (ly:ledger-line-spanner::print grob))
     ; (ifaces (ly:grob-interfaces grob))

     (noteheads (ly:grob-oect grob 'note-heads))
     (new-stil (box-stencil (stencil-with-color stil  (rgb-color )###";

  ss <<
    gGlobalLpsr2lilypondOahGroup->getLedgerLinesColorRGB ().getR () <<
    ' ' <<
    gGlobalLpsr2lilypondOahGroup->getLedgerLinesColorRGB ().getG () <<
    ' ' <<
    gGlobalLpsr2lilypondOahGroup->getLedgerLinesColorRGB ().getB ();

  ss <<
R"###()) 0.1 1))
     )

    (display "noteheads: ")(display noteheads)(newline)(newline)
    ; (display (ly:grob-properties grob))(newline)(newline)
    ; (display ifaces)(newline)(newline)

    new-stil))
)###";

  std::string
    schemeFunctionName =
      "coloredLedgerLines",

  schemeFunctionDescription =
R"(
% A function to color the staves ledger lines other that black
)",

  schemeFunctionCode = ss.str ();

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setHiddenMeasureAndBarLineIsNeeded ()
{
  if (! fHiddenMeasureAndBarLineIsNeeded) {
    addHiddenMeasureAndBarLineToScore ();

    fHiddenMeasureAndBarLineIsNeeded = true;
  }
}

void lpsrScore::addHiddenMeasureAndBarLineToScore ()
{
  std::stringstream ss;

  ss <<
R"###(hiddenMeasureAndBarLine = {
  % the hidden measure and bar line
  % \cadenzaOn turns off automatic calculation of bar numbers
  \cadenzaOn
  \once \omit Score.TimeSignature
  \time 1/16
  s16 \bar ""
  \cadenzaOff
}
)###";

  std::string
    schemeFunctionName =
      "hiddenMeasureAndBarLine",

  schemeFunctionDescription =
R"(
% A function to avoid having two marks at the same point in time,
% which LilyPond doesn't allow
)",

  schemeFunctionCode = ss.str ();

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setMergeStaffCommonRestsIsNeeded ()
{
  if (! fMergeStaffCommonRestsIsNeeded) {
    addMergeStaffCommonRestsToScore ();

    fMergeStaffCommonRestsIsNeeded = true;
  }
}

void lpsrScore::addMergeStaffCommonRestsToScore ()
{
  std::stringstream ss;

  ss <<
R"###(%% http://lsr.di.unimi.it/LSR/Item?id=336
%% see also http://code.google.com/p/lilypond/issues/detail?id=1228

%% Usage:
%%   \new Staff \with {
%%     \override RestCollision.positioning-done = #merge-rests-on-positioning
%%   }
%%   << \somevoice \\ \othervoice >>
%% or (globally):
%%   \layout {
%%     \context {
%%       \Staff
%%       \override RestCollision.positioning-done = #merge-rests-on-positioning
%%     }
%%   }
%%
%% Limitations:
%% - only handles two voices
%% - does not handle multi-measure rests

#(define (rest-score r)
   (let ((score 0)
         (yoff (ly:grob-property-data r 'Y-offset))
         (sp (ly:grob-property-data r 'staff-position)))
     (if (number? yoff)
         (set! score (+ score 2))
         (if (eq? yoff 'calculation-in-progress)
             (set! score (- score 3))))
     (and (number? sp)
          (<= 0 2 sp)
          (set! score (+ score 2))
          (set! score (- score (abs (- 1 sp)))))
     score))

#(define (merge-rests-on-positioning grob)
   (let* ((can-merge #f)
          (elts (ly:grob-oect grob 'elements))
          (num-elts (and (ly:grob-array? elts)
                         (ly:grob-array-length elts)))
          (two-voice? (= num-elts 2)))
     (if two-voice?
         (let* ((v1-grob (ly:grob-array-ref elts 0))
                (v2-grob (ly:grob-array-ref elts 1))
                (v1-rest (ly:grob-oect v1-grob 'rest))
                (v2-rest (ly:grob-oect v2-grob 'rest)))
           (and
            (ly:grob? v1-rest)
            (ly:grob? v2-rest)
            (let* ((v1-duration-log (ly:grob-property v1-rest 'duration-log))
                   (v2-duration-log (ly:grob-property v2-rest 'duration-log))
                   (v1-dot (ly:grob-oect v1-rest 'dot))
                   (v2-dot (ly:grob-oect v2-rest 'dot))
                   (v1-dot-count (and (ly:grob? v1-dot)
                                      (ly:grob-property v1-dot 'dot-count -1)))
                   (v2-dot-count (and (ly:grob? v2-dot)
                                      (ly:grob-property v2-dot 'dot-count -1))))
              (set! can-merge
                    (and
                     (number? v1-duration-log)
                     (number? v2-duration-log)
                     (= v1-duration-log v2-duration-log)
                     (eq? v1-dot-count v2-dot-count)))
              (if can-merge
                  ; keep the rest that looks best:
                  (let* ((keep-v1? (>= (rest-score v1-rest)
                                       (rest-score v2-rest)))
                         (rest-to-keep (if keep-v1? v1-rest v2-rest))
                         (dot-to-kill (if keep-v1? v2-dot v1-dot)))
                    ; uncomment if you're curious of which rest was selected:
                    ;(ly:grob-set-property! v1-rest 'color green)
                    ;(ly:grob-set-property! v2-rest 'color blue)
                    (ly:grob-suicide! (if keep-v1? v2-rest v1-rest))
                    (if (ly:grob? dot-to-kill)
                        (ly:grob-suicide! dot-to-kill))
                    (ly:grob-set-property! rest-to-keep 'direction 0)
                    (ly:rest::y-offset-callback rest-to-keep)))))))
     (if can-merge
         #t
         (ly:rest-collision::calc-positioning-done grob))))
)###";

  std::string
    schemeFunctionName =
      "MergeStaffCommonRests",

  schemeFunctionDescription =
R"(
% Functions to merge staff common rests in two voices
)",

  schemeFunctionCode = ss.str ();

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setTextSpannerWithCenteredTextIsNeeded ()
{
  if (! fTextSpannerWithCenteredTextIsNeeded) {
    addTextSpannerWithCenteredTextToScore ();

    fTextSpannerWithCenteredTextIsNeeded = true;
  }
}

void lpsrScore::addTextSpannerWithCenteredTextToScore ()
{
  std::stringstream ss;

  ss <<
R"###(
% Annotation bracket with centred text.
% Andrew Bernard and Thomas Morley

TextSpannerWithCenteredText =
#(define-music-function (text) (string?)
   "Use TextSpanner semantics to create spanner brackets with centred text"
   #{
     \once \override TextSpanner.after-line-breaking =
     #(lambda (grob)
        (let* (
                ; get stencil of grob
                (stil (ly:grob-property grob 'stencil))
                ; get spanner length
                (spanner-len (interval-length (ly:stencil-extent stil X)))
                ; make stencil from text arg
                (text-stil (grob-interpret-markup grob (markup text)))
                ; get text length
                (text-len (interval-length (ly:stencil-extent text-stil X))))
          ; if text length exceeds the spanner length we cannot really proceed.
          ; do nothing - make an ordinary text spanner and warn.
          (if (>= text-len spanner-len)
              (begin
               (ly:warning "text length longer than spanner")
               #f
               )
              (let* (
                      ; get direction, up or down
                      (dir (ly:grob-property grob 'direction))
                      ; some padding
                      (padding 1)
                      ; line thickness
                      (thickness 0.25)
                      ; calculate length considering text length
                      (path-part-len (/ (- spanner-len text-len) 2))
                      ; make left bracket stencil
                      (path-left-part-stil
                       (make-path-stencil
                        `(
                           moveto 0 ,(* -1 dir)
                           lineto 0 0
                           lineto ,path-part-len 0
                           )
                        thickness 1 1 #f))
                      ; make right bracket stencil
                      (path-right-part-stil
                       (make-path-stencil
                        `(
                           moveto ,path-part-len ,(* -1 dir)
                           lineto ,path-part-len 0
                           lineto 0 0
                           )
                        thickness 1 1 #f))
                      ; make complete stencil combining left and right parts
                      ; and text
                      (full-stil
                       (stack-stencils X RIGHT padding
                         (list
                          path-left-part-stil
                          (centered-stencil text-stil)
                          path-right-part-stil)))
                      )
                ; set grob stencil to fully constructed stencil
                (ly:grob-set-property! grob 'stencil full-stil)
                ))))
   #}
   )
)###";

  std::string
    schemeFunctionName =
      "TextSpannerWithCenteredText",

  schemeFunctionDescription =
R"(
% Function to create text spanners with text centered in it
)",

  schemeFunctionCode = ss.str ();

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setMergeMultiMeasureRestsIsNeeded ()
{
  if (! fMergeMultiMeasureRestsIsNeeded) {
    addMergeMultiMeasureRestsToScore ();

    fMergeMultiMeasureRestsIsNeeded = true;
  }
}

void lpsrScore::addMergeMultiMeasureRestsToScore ()
{
  std::stringstream ss;

  ss <<
R"###(
% thanks to jean@abou-samra.fr

#(define (append-merge x l r)
   "Add x to the head of list l, merging skips,
and if r is true also merging multi-measure rests."
   (if (and (pair? l)
            (ly:music? x)
            (ly:music? (car l))
            (or (and (music-is-of-type? x 'skip-event)
                     (music-is-of-type? (car l) 'skip-event))
                (and r
                     (music-is-of-type? x 'multi-measure-rest)
                     (music-is-of-type? (car l) 'multi-measure-rest)))
            (not (pair? (ly:music-property (car l) 'articulations))))
       (let ((total
              (ly:moment-add
               (ly:music-duration-length (car l))
               (ly:music-duration-length x)
               )))
         (set! (ly:music-property x 'duration)
               (make-duration-of-length total))
         (cons x (cdr l)))
       (cons x l)))

mergeSkips = #(define-music-function
               (parser location rests-also music) ((boolean?) ly:music?)
               "Merge successive skips in sequential music,
  optionally merge full-measure rests as well."
               (music-map
                (lambda (m)
                  (if (music-is-of-type? m 'sequential-music)
                      (ly:music-set-property! m
                                              'elements
                                              (fold-right (lambda (x l)
                                                            (append-merge x l rests-also))
                                                          '()
                                                          (ly:music-property m 'elements))))
                  m)
                music))

mergeMultiMeasureRests = #(define-music-function
                      (parser location music) (ly:music?)
                      #{ \mergeSkips ##t $music #})
)###";

  std::string
    schemeFunctionName =
      "MergeMultiMeasureRests",

  schemeFunctionDescription =
R"(
% Function to create text spanners with text centered in it
)",

  schemeFunctionCode = ss.str ();

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::setBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded ()
{
  if (! fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded) {
    addBarNumberEveryNAndAtTheBeginningOfLinesToScore ();

    fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded = true;
  }
}

void lpsrScore::addBarNumberEveryNAndAtTheBeginningOfLinesToScore ()
{
  std::stringstream ss;

  ss <<
R"###(
% thanks to jean@abou-samra.fr

%{
The idea is that the Bar_number_engraver gets duplicated,
in Score and and in the top Staff.

The Score prints a bar number at the beginning of every line, as usual.

The Staff prints a bar number every 5th measure,
but only in the middle of a line,
so that it won't duplicate the number typeset by the Score
if it happens to be at the beginning of the line.
%}

barNumberEveryNAndAtTheBeginningOfLines = \with {
  \consists Bar_number_engraver
  barNumberVisibility = #(every-nth-bar-number-visible 5)
  \override BarNumber.break-visibility = #center-visible
}

%<<
%  \new Staff
%  \with \barNumberEveryNAndAtTheBeginningOfLines
%  \repeat unfold 50 { c'1 }
%  \repeat unfold 50 { c'1 }
%>>
)###";

  std::string
    schemeFunctionName =
      "MergeMultiMeasureRests",

  schemeFunctionDescription =
R"(
% Function to create text spanners with text centered in it
)",

  schemeFunctionCode = ss.str ();

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme function '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::addDateAndTimeSchemeFunctionsToScore ()
{
  std::string
    schemeFunctionName =
      "date & time",

    schemeFunctionDescription =
R"(
% A set of functions to obtain the LilyPond file creation or modification time.
)",

    schemeFunctionCode =
R"(
#(define comml           (object->string (command-line)))
#(define loc             (+ (string-rindex comml #\space ) 2))
#(define commllen        (- (string-length comml) 2))
#(define filen           (substring comml loc commllen))
#(define siz             (object->string (stat:size (stat filen))))
#(define ver             (object->string (lilypond-version)))
#(define dat             (strftime "%d/%m/%Y" (localtime (current-time))))
#(define tim             (strftime "%H:%M:%S" (localtime (current-time))))
#(define modTime         (stat:mtime (stat filen)))
#(define modTimeAsString (strftime "%d/%m/%Y, %H:%M:%S" (localtime modTime)))
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme functions for '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

void lpsrScore::addPointAndClickOffSchemeFunctionsToScore ()
{
  std::string
    schemeFunctionName =
      "pointAndClickOff",

    schemeFunctionDescription =
R"(
% \pointAndClickOff to reduce the size of the produced PDF file.
)",

    schemeFunctionCode =
R"(
\pointAndClickOff
)";

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceSchemeFunctions ()) {
    std::stringstream ss;

    ss <<
      "Creating Scheme functions for '" << schemeFunctionName << "'";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  // create the Scheme function
  S_lpsrSchemeFunction
    schemeFunction =
      lpsrSchemeFunction::create (
        1, // inputLineNumber, JMI ???
        schemeFunctionName,
        schemeFunctionDescription,
        schemeFunctionCode);

  // register it in the Scheme functions map
  fScoreSchemeFunctionsMap [schemeFunctionName] =
    schemeFunction;
}

/* JMI
void lpsrScore::appendVoiceUseToStoreCommand (const S_msrVoice& voice)
{
  S_lpsrUseVoiceCommand
    useVoiceCommand =
      lpsrUseVoiceCommand::create (
        fInputStartLineNumber,
        voice);

  fScoreBlock->
    appendVoiceUseToParallelMusicBLock (useVoiceCommand);
}

void lpsrScore::appendLyricsUseToStoreCommand (const S_msrStanza& stanza)
{
  S_lpsrNewLyricsBlock
    newLyricsCommand =
      lpsrNewLyricsBlock::create (
        fInputStartLineNumber,
        stanza,
        stanza->getStanzaUpLinkToVoice ());

  fScoreBlock->
    appendLyricsUseToParallelMusicBLock (newLyricsCommand);
}
*/

void lpsrScore::acceptIn (basevisitor* v)
{
#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceLpsrVisitors ()) {
    std::stringstream ss;

    ss <<
      "% ==> lpsrScore::acceptIn ()";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  if (visitor<S_lpsrScore>*
    p =
      dynamic_cast<visitor<S_lpsrScore>*> (v)) {
        S_lpsrScore elem = this;

#ifdef MF_TRACE_IS_ENABLED
        if (gLpsrOahGroup->getTraceLpsrVisitors ()) {
          std::stringstream ss;

          ss <<
            "% ==> Launching lpsrScore::visitStart ()";

          gWaeHandler->waeTrace (
            __FILE__, __LINE__,
            ss.str ());
        }
#endif // MF_TRACE_IS_ENABLED
        p->visitStart (elem);
  }
}

void lpsrScore::acceptOut (basevisitor* v)
{
#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceLpsrVisitors ()) {
    std::stringstream ss;

    ss <<
      "% ==> lpsrScore::acceptOut ()";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  if (visitor<S_lpsrScore>*
    p =
      dynamic_cast<visitor<S_lpsrScore>*> (v)) {
        S_lpsrScore elem = this;

#ifdef MF_TRACE_IS_ENABLED
        if (gLpsrOahGroup->getTraceLpsrVisitors ()) {
          std::stringstream ss;

          ss <<
            "% ==> Launching lpsrScore::visitEnd ()";

          gWaeHandler->waeTrace (
            __FILE__, __LINE__,
            ss.str ());
        }
#endif // MF_TRACE_IS_ENABLED
        p->visitEnd (elem);
  }
}

void lpsrScore::browseData (basevisitor* v)
{
#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceLpsrVisitors ()) {
    std::stringstream ss;

    ss <<
      "% ==> lpsrScore::browseData ()";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED

  if (fInputSourceNameComment) {
    // browse the input source name comment
    msrBrowser<lpsrComment> browser (v);
    browser.browse (*fInputSourceNameComment);
  }

  if (fRunDateComment) {
    // browse the conversion date comment
    msrBrowser<lpsrComment> browser (v);
    browser.browse (*fRunDateComment);
  }

  if (fCommandLineAsSuppliedComment) {
    // browse the command line as supplied comment
    msrBrowser<lpsrComment> browser (v);
    browser.browse (*fCommandLineAsSuppliedComment);
  }

  if (fCommandLineLongOptionsComment) {
    // browse the command line long options comment
    msrBrowser<lpsrComment> browser (v);
    browser.browse (*fCommandLineLongOptionsComment);
  }

  if (fCommandLineShortOptionsComment) {
    // browse the command line short options comment
    msrBrowser<lpsrComment> browser (v);
    browser.browse (*fCommandLineShortOptionsComment);
  }

  {
    // browse the Scheme function map
    for (
      std::map<std::string, S_lpsrSchemeFunction>::const_iterator i =
        fScoreSchemeFunctionsMap.begin ();
      i != fScoreSchemeFunctionsMap.end ();
      ++i
    ) {
      // browse the Scheme function
      msrBrowser<lpsrSchemeFunction> browser (v);
      browser.browse (*(*i).second);
    } // for
  }

  if (fScoreHeader) {
    // browse the score header
    msrBrowser<lpsrHeader> browser (v);
    browser.browse (*fScoreHeader);
  }

  if (fScorePaper) {
    // browse the score paper
    msrBrowser<lpsrPaper> browser (v);
    browser.browse (*fScorePaper);
  }

  if (fScoreLayout) { // JMI
    // browse the score layout
    msrBrowser<lpsrLayout> browser (v);
    browser.browse (*fScoreLayout);
  }

  {
    // browse the voices and stanzas list
    for (
      std::list<S_msrElement>::const_iterator i = fScoreElementsList.begin ();
      i != fScoreElementsList.end ();
      ++i
    ) {
      // browse the element
      msrBrowser<msrElement> browser (v);
      browser.browse (*(*i));
    } // for
  }

  {
    // browse the score blocks list
    for (
      std::list<S_lpsrBookBlock>::const_iterator i = fScoreBookBlocksList.begin ();
      i != fScoreBookBlocksList.end ();
      ++i
    ) {
      // browse the element
      msrBrowser<lpsrBookBlock> browser (v);
      browser.browse (*(*i));
    } // for
  }

#ifdef MF_TRACE_IS_ENABLED
  if (gLpsrOahGroup->getTraceLpsrVisitors ()) {
    std::stringstream ss;

    ss <<
      "% <== lpsrScore::browseData ()";

    gWaeHandler->waeTrace (
      __FILE__, __LINE__,
      ss.str ());
  }
#endif // MF_TRACE_IS_ENABLED
}

void lpsrScore::printFull (std::ostream& os) const
{
  os <<
    std::string ("LPSR Score printfull()")
      + ", " +
    gLanguage->fullVersion () <<
    std::endl << std::endl;

#ifdef MF_SANITY_CHECKS_ARE_ENABLED
  // sanity check
  mfAssert (
    __FILE__, __LINE__,
    fEmbeddedMsrScore != nullptr,
    "fEmbeddedMsrScore is null");
#endif // MF_SANITY_CHECKS_ARE_ENABLED

  ++gIndenter;

  // print the embedded MSR score (without the voices)
  fEmbeddedMsrScore->
    printFull (os);
  os << std::endl;

  // are there needed things?
  const int fieldWidth = 49;

  os << std::left <<
    std::setw (fieldWidth) <<
    "fJianpuFileIncludeIsNeeded" << ": " <<
    fJianpuFileIncludeIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fScmAndAccregSchemeModulesAreNeeded" << ": " <<
    fScmAndAccregSchemeModulesAreNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTongueSchemeFunctionIsNeeded" << ": " <<
    fTongueSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fCustomShortBarLineSchemeFunctionIsNeeded" << ": " <<
    fCustomShortBarLineSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fEditorialAccidentalSchemeFunctionIsNeeded" << ": " <<
    fEditorialAccidentalSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDynamicsSchemeFunctionIsNeeded" << ": " <<
    fDynamicsSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTupletsCurvedBracketsSchemeFunctionIsNeeded" << ": " <<
    fTupletsCurvedBracketsSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fAfterSchemeFunctionIsNeeded" << ": " <<
    fAfterSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTempoNotesRelationshipSchemeFunctionIsNeeded" << ": " <<
    fTempoNotesRelationshipSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fGlissandoWithTextSchemeFunctionsIsNeeded" << ": " <<
    fGlissandoWithTextSchemeFunctionsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fOtherDynamicSchemeFunctionIsNeeded" << ": " <<
    fOtherDynamicSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fAutoVoicesSchemeFunctionIsNeeded" << ": " <<
    fAutoVoicesSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fSchleiferSchemeFunctionIsNeeded" << ": " <<
    fSchleiferSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fScoopSchemeFunctionIsNeeded" << ": " <<
    fScoopSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDampMarkupIsNeeded" << ": " <<
    fDampMarkupIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDampAllMarkupIsNeeded" << ": " <<
    fDampAllMarkupIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fWhiteNoteHeadsIsNeeded" << ": " <<
    fWhiteNoteHeadsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fBoxAroundNextBarNumberIsNeeded" << ": " <<
    fBoxAroundNextBarNumberIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fJazzChordsDisplayIsNeeded" << ": " <<
    fJazzChordsDisplayIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fColoredLedgerLinesIsNeeded" << ": " <<
    fColoredLedgerLinesIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fHiddenMeasureAndBarLineIsNeeded" << ": " <<
    fHiddenMeasureAndBarLineIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fMergeStaffCommonRestsIsNeeded" << ": " <<
    fMergeStaffCommonRestsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTextSpannerWithCenteredTextIsNeeded" << ": " <<
    fTextSpannerWithCenteredTextIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fMergeMultiMeasureRestsIsNeeded" << ": " <<
    fMergeMultiMeasureRestsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded" << ": " <<
    fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded <<
    std::endl << std::endl;

  os <<
    "LPSR basic information" <<
    std::endl << std::endl;

  ++gIndenter;

  // print LPSR basic information
  fScoreHeader->print (os);
  os << std::endl;

  fScorePaper->print (os);
  os << std::endl;

  if (fScoreLayout) {
    fScoreLayout->print (os);
    os << std::endl;
  }

  --gIndenter;

  // print the voices and stanzas
  if (fScoreElementsList.size ()) {
    os <<
      "Voices & Stanzas" <<
      std::endl << std::endl;

    ++gIndenter;

    std::list<S_msrElement>::const_iterator
      iBegin = fScoreElementsList.begin (),
      iEnd   = fScoreElementsList.end (),
      i      = iBegin;
    for ( ; ; ) {
      (*i)->print (os);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  // print the book blocks
  if (fScoreBookBlocksList.size ()) {
    os <<
      "Book blocks" <<
      std::endl << std::endl;
    ++gIndenter;

    std::list<S_lpsrBookBlock>::const_iterator
      iBegin = fScoreBookBlocksList.begin (),
      iEnd   = fScoreBookBlocksList.end (),
      i      = iBegin;
    for ( ; ; ) {
      (*i)->print (os);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  --gIndenter;
}

void lpsrScore::printSummary (std::ostream& os) const
{
  os <<
    std::string ("LPSR Score")
      + ", " +
    gLanguage->fullVersion () <<
    std::endl << std::endl;

#ifdef MF_SANITY_CHECKS_ARE_ENABLED
  // sanity check
  mfAssert (
    __FILE__, __LINE__,
    fEmbeddedMsrScore != nullptr,
    "fEmbeddedMsrScore is null");
#endif // MF_SANITY_CHECKS_ARE_ENABLED

  ++gIndenter;

  // print the embedded MSR score (without the voices)
  fEmbeddedMsrScore->
    printSummary (os);
  os << std::endl;

  // are there needed things?
  const int fieldWidth = 49;

  os << std::left <<
    std::setw (fieldWidth) <<
    "fJianpuFileIncludeIsNeeded" << ": " <<
    fJianpuFileIncludeIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fScmAndAccregSchemeModulesAreNeeded" << ": " <<
    fScmAndAccregSchemeModulesAreNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTongueSchemeFunctionIsNeeded" << ": " <<
    fTongueSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fCustomShortBarLineSchemeFunctionIsNeeded" << ": " <<
    fCustomShortBarLineSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fEditorialAccidentalSchemeFunctionIsNeeded" << ": " <<
    fEditorialAccidentalSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDynamicsSchemeFunctionIsNeeded" << ": " <<
    fDynamicsSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTupletsCurvedBracketsSchemeFunctionIsNeeded" << ": " <<
    fTupletsCurvedBracketsSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fAfterSchemeFunctionIsNeeded" << ": " <<
    fAfterSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTempoNotesRelationshipSchemeFunctionIsNeeded" << ": " <<
    fTempoNotesRelationshipSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fGlissandoWithTextSchemeFunctionsIsNeeded" << ": " <<
    fGlissandoWithTextSchemeFunctionsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fOtherDynamicSchemeFunctionIsNeeded" << ": " <<
    fOtherDynamicSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fAutoVoicesSchemeFunctionIsNeeded" << ": " <<
    fAutoVoicesSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fSchleiferSchemeFunctionIsNeeded" << ": " <<
    fSchleiferSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fScoopSchemeFunctionIsNeeded" << ": " <<
    fScoopSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDampMarkupIsNeeded" << ": " <<
    fDampMarkupIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDampAllMarkupIsNeeded" << ": " <<
    fDampAllMarkupIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fWhiteNoteHeadsIsNeeded" << ": " <<
    fWhiteNoteHeadsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fBoxAroundNextBarNumberIsNeeded" << ": " <<
    fBoxAroundNextBarNumberIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fJazzChordsDisplayIsNeeded" << ": " <<
    fJazzChordsDisplayIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fColoredLedgerLinesIsNeeded" << ": " <<
    fColoredLedgerLinesIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fHiddenMeasureAndBarLineIsNeeded" << ": " <<
    fHiddenMeasureAndBarLineIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fMergeStaffCommonRestsIsNeeded" << ": " <<
    fMergeStaffCommonRestsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTextSpannerWithCenteredTextIsNeeded" << ": " <<
    fTextSpannerWithCenteredTextIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fMergeMultiMeasureRestsIsNeeded" << ": " <<
    fMergeMultiMeasureRestsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded" << ": " <<
    fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded <<
    std::endl << std::endl;

  os <<
    "LPSR basic information" <<
    std::endl << std::endl;

  ++gIndenter;

  // print LPSR basic information
  fScoreHeader->print (os);
  os << std::endl;

  fScorePaper->print (os);
  os << std::endl;

  if (fScoreLayout) {
    fScoreLayout->print (os);
    os << std::endl;
  }

  --gIndenter;

  // print the voices and stanzas
  if (fScoreElementsList.size ()) {
    os <<
      "Voices & Stanzas" <<
      std::endl << std::endl;

    ++gIndenter;

    std::list<S_msrElement>::const_iterator
      iBegin = fScoreElementsList.begin (),
      iEnd   = fScoreElementsList.end (),
      i      = iBegin;
    for ( ; ; ) {
      (*i)->print (os);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  // print the book blocks
  if (fScoreBookBlocksList.size ()) {
    os <<
      "Book blocks" <<
      std::endl << std::endl;
    ++gIndenter;

    std::list<S_lpsrBookBlock>::const_iterator
      iBegin = fScoreBookBlocksList.begin (),
      iEnd   = fScoreBookBlocksList.end (),
      i      = iBegin;
    for ( ; ; ) {
      (*i)->print (os);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  --gIndenter;
}

void lpsrScore::printNames (std::ostream& os) const
{
  os <<
    std::string ("LPSR Score")
      + ", " +
    gLanguage->fullVersion () <<
    std::endl << std::endl;

#ifdef MF_SANITY_CHECKS_ARE_ENABLED
  // sanity check
  mfAssert (
    __FILE__, __LINE__,
    fEmbeddedMsrScore != nullptr,
    "fEmbeddedMsrScore is null");
#endif // MF_SANITY_CHECKS_ARE_ENABLED

  ++gIndenter;

  // print the embedded MSR score (without the voices)
//   fEmbeddedMsrScore->
//     printNames (os);
  os << std::endl;

  // are there needed things?
  const int fieldWidth = 49;

  os << std::left <<
    std::setw (fieldWidth) <<
    "fJianpuFileIncludeIsNeeded" << ": " <<
    fJianpuFileIncludeIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fScmAndAccregSchemeModulesAreNeeded" << ": " <<
    fScmAndAccregSchemeModulesAreNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTongueSchemeFunctionIsNeeded" << ": " <<
    fTongueSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fCustomShortBarLineSchemeFunctionIsNeeded" << ": " <<
    fCustomShortBarLineSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fEditorialAccidentalSchemeFunctionIsNeeded" << ": " <<
    fEditorialAccidentalSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDynamicsSchemeFunctionIsNeeded" << ": " <<
    fDynamicsSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTupletsCurvedBracketsSchemeFunctionIsNeeded" << ": " <<
    fTupletsCurvedBracketsSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fAfterSchemeFunctionIsNeeded" << ": " <<
    fAfterSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTempoNotesRelationshipSchemeFunctionIsNeeded" << ": " <<
    fTempoNotesRelationshipSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fGlissandoWithTextSchemeFunctionsIsNeeded" << ": " <<
    fGlissandoWithTextSchemeFunctionsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fOtherDynamicSchemeFunctionIsNeeded" << ": " <<
    fOtherDynamicSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fAutoVoicesSchemeFunctionIsNeeded" << ": " <<
    fAutoVoicesSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fSchleiferSchemeFunctionIsNeeded" << ": " <<
    fSchleiferSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fScoopSchemeFunctionIsNeeded" << ": " <<
    fScoopSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDampMarkupIsNeeded" << ": " <<
    fDampMarkupIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDampAllMarkupIsNeeded" << ": " <<
    fDampAllMarkupIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fWhiteNoteHeadsIsNeeded" << ": " <<
    fWhiteNoteHeadsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fBoxAroundNextBarNumberIsNeeded" << ": " <<
    fBoxAroundNextBarNumberIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fJazzChordsDisplayIsNeeded" << ": " <<
    fJazzChordsDisplayIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fColoredLedgerLinesIsNeeded" << ": " <<
    fColoredLedgerLinesIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fHiddenMeasureAndBarLineIsNeeded" << ": " <<
    fHiddenMeasureAndBarLineIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fMergeStaffCommonRestsIsNeeded" << ": " <<
    fMergeStaffCommonRestsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTextSpannerWithCenteredTextIsNeeded" << ": " <<
    fTextSpannerWithCenteredTextIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fMergeMultiMeasureRestsIsNeeded" << ": " <<
    fMergeMultiMeasureRestsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded" << ": " <<
    fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded <<
    std::endl << std::endl;

  os <<
    "LPSR basic information" <<
    std::endl << std::endl;

  ++gIndenter;

  // print LPSR basic information
  fScoreHeader->print (os);
  os << std::endl;

  fScorePaper->print (os);
  os << std::endl;

  if (fScoreLayout) {
    fScoreLayout->print (os);
    os << std::endl;
  }

  --gIndenter;

  // print the voices and stanzas
  if (fScoreElementsList.size ()) {
    os <<
      "Voices & Stanzas" <<
      std::endl << std::endl;

    ++gIndenter;

    std::list<S_msrElement>::const_iterator
      iBegin = fScoreElementsList.begin (),
      iEnd   = fScoreElementsList.end (),
      i      = iBegin;
    for ( ; ; ) {
      (*i)->print (os);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  // print the book blocks
  if (fScoreBookBlocksList.size ()) {
    os <<
      "Book blocks" <<
      std::endl << std::endl;
    ++gIndenter;

    std::list<S_lpsrBookBlock>::const_iterator
      iBegin = fScoreBookBlocksList.begin (),
      iEnd   = fScoreBookBlocksList.end (),
      i      = iBegin;
    for ( ; ; ) {
      (*i)->print (os);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  --gIndenter;
}

void lpsrScore::printFlatView (std::ostream& os) const
{
  os <<
    std::string ("LPSR Score")
      + ", " +
    gLanguage->fullVersion () <<
    std::endl << std::endl;

#ifdef MF_SANITY_CHECKS_ARE_ENABLED
  // sanity check
  mfAssert (
    __FILE__, __LINE__,
    fEmbeddedMsrScore != nullptr,
    "fEmbeddedMsrScore is null");
#endif // MF_SANITY_CHECKS_ARE_ENABLED

  ++gIndenter;

  // print the embedded MSR score (without the voices)
//   fEmbeddedMsrScore->
//     printNames (os);
  os << std::endl;

  // are there needed things?
  const int fieldWidth = 49;

  os << std::left <<
    std::setw (fieldWidth) <<
    "fJianpuFileIncludeIsNeeded" << ": " <<
    fJianpuFileIncludeIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fScmAndAccregSchemeModulesAreNeeded" << ": " <<
    fScmAndAccregSchemeModulesAreNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTongueSchemeFunctionIsNeeded" << ": " <<
    fTongueSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fCustomShortBarLineSchemeFunctionIsNeeded" << ": " <<
    fCustomShortBarLineSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fEditorialAccidentalSchemeFunctionIsNeeded" << ": " <<
    fEditorialAccidentalSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDynamicsSchemeFunctionIsNeeded" << ": " <<
    fDynamicsSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTupletsCurvedBracketsSchemeFunctionIsNeeded" << ": " <<
    fTupletsCurvedBracketsSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fAfterSchemeFunctionIsNeeded" << ": " <<
    fAfterSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTempoNotesRelationshipSchemeFunctionIsNeeded" << ": " <<
    fTempoNotesRelationshipSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fGlissandoWithTextSchemeFunctionsIsNeeded" << ": " <<
    fGlissandoWithTextSchemeFunctionsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fOtherDynamicSchemeFunctionIsNeeded" << ": " <<
    fOtherDynamicSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fAutoVoicesSchemeFunctionIsNeeded" << ": " <<
    fAutoVoicesSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fSchleiferSchemeFunctionIsNeeded" << ": " <<
    fSchleiferSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fScoopSchemeFunctionIsNeeded" << ": " <<
    fScoopSchemeFunctionIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDampMarkupIsNeeded" << ": " <<
    fDampMarkupIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fDampAllMarkupIsNeeded" << ": " <<
    fDampAllMarkupIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fWhiteNoteHeadsIsNeeded" << ": " <<
    fWhiteNoteHeadsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fBoxAroundNextBarNumberIsNeeded" << ": " <<
    fBoxAroundNextBarNumberIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fJazzChordsDisplayIsNeeded" << ": " <<
    fJazzChordsDisplayIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fColoredLedgerLinesIsNeeded" << ": " <<
    fColoredLedgerLinesIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fHiddenMeasureAndBarLineIsNeeded" << ": " <<
    fHiddenMeasureAndBarLineIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fMergeStaffCommonRestsIsNeeded" << ": " <<
    fMergeStaffCommonRestsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fTextSpannerWithCenteredTextIsNeeded" << ": " <<
    fTextSpannerWithCenteredTextIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fMergeMultiMeasureRestsIsNeeded" << ": " <<
    fMergeMultiMeasureRestsIsNeeded <<
    std::endl <<

    std::setw (fieldWidth) <<
    "fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded" << ": " <<
    fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded <<
    std::endl << std::endl;

  os <<
    "LPSR basic information" <<
    std::endl << std::endl;

  ++gIndenter;

  // print LPSR basic information
  fScoreHeader->print (os);
  os << std::endl;

  fScorePaper->print (os);
  os << std::endl;

  if (fScoreLayout) {
    fScoreLayout->print (os);
    os << std::endl;
  }

  --gIndenter;

  // print the voices and stanzas
  if (fScoreElementsList.size ()) {
    os <<
      "Voices & Stanzas" <<
      std::endl << std::endl;

    ++gIndenter;

    std::list<S_msrElement>::const_iterator
      iBegin = fScoreElementsList.begin (),
      iEnd   = fScoreElementsList.end (),
      i      = iBegin;
    for ( ; ; ) {
      (*i)->print (os);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  // print the book blocks
  if (fScoreBookBlocksList.size ()) {
    os <<
      "Book blocks" <<
      std::endl << std::endl;
    ++gIndenter;

    std::list<S_lpsrBookBlock>::const_iterator
      iBegin = fScoreBookBlocksList.begin (),
      iEnd   = fScoreBookBlocksList.end (),
      i      = iBegin;
    for ( ; ; ) {
      (*i)->print (os);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  --gIndenter;
}

void lpsrScore::printSlices (std::ostream& os) const
{
  os <<
    std::string ("LPSR Score")
      + ", " +
   "gLanguage->printSlices ()" << // JMI v0.9.70
    std::endl << std::endl;

#ifdef MF_SANITY_CHECKS_ARE_ENABLED
  // sanity check
  mfAssert (
    __FILE__, __LINE__,
    fEmbeddedMsrScore != nullptr,
    "fEmbeddedMsrScore is null");
#endif // MF_SANITY_CHECKS_ARE_ENABLED

  ++gIndenter;

  // print the embedded MSR score (without the voices)
//   fEmbeddedMsrScore->
//     printNames (os);
  os << std::endl;

  // are there needed things?
//   const int fieldWidth = 49;

//   os << std::left <<
//     std::setw (fieldWidth) <<
//     "fJianpuFileIncludeIsNeeded" << ": " <<
//     fJianpuFileIncludeIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fScmAndAccregSchemeModulesAreNeeded" << ": " <<
//     fScmAndAccregSchemeModulesAreNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fTongueSchemeFunctionIsNeeded" << ": " <<
//     fTongueSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fCustomShortBarLineSchemeFunctionIsNeeded" << ": " <<
//     fCustomShortBarLineSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fEditorialAccidentalSchemeFunctionIsNeeded" << ": " <<
//     fEditorialAccidentalSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fDynamicsSchemeFunctionIsNeeded" << ": " <<
//     fDynamicsSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fTupletsCurvedBracketsSchemeFunctionIsNeeded" << ": " <<
//     fTupletsCurvedBracketsSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fAfterSchemeFunctionIsNeeded" << ": " <<
//     fAfterSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fTempoNotesRelationshipSchemeFunctionIsNeeded" << ": " <<
//     fTempoNotesRelationshipSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fGlissandoWithTextSchemeFunctionsIsNeeded" << ": " <<
//     fGlissandoWithTextSchemeFunctionsIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fOtherDynamicSchemeFunctionIsNeeded" << ": " <<
//     fOtherDynamicSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fAutoVoicesSchemeFunctionIsNeeded" << ": " <<
//     fAutoVoicesSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fSchleiferSchemeFunctionIsNeeded" << ": " <<
//     fSchleiferSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fScoopSchemeFunctionIsNeeded" << ": " <<
//     fScoopSchemeFunctionIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fDampMarkupIsNeeded" << ": " <<
//     fDampMarkupIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fDampAllMarkupIsNeeded" << ": " <<
//     fDampAllMarkupIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fWhiteNoteHeadsIsNeeded" << ": " <<
//     fWhiteNoteHeadsIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fBoxAroundNextBarNumberIsNeeded" << ": " <<
//     fBoxAroundNextBarNumberIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fJazzChordsDisplayIsNeeded" << ": " <<
//     fJazzChordsDisplayIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fColoredLedgerLinesIsNeeded" << ": " <<
//     fColoredLedgerLinesIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fHiddenMeasureAndBarLineIsNeeded" << ": " <<
//     fHiddenMeasureAndBarLineIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fMergeStaffCommonRestsIsNeeded" << ": " <<
//     fMergeStaffCommonRestsIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fTextSpannerWithCenteredTextIsNeeded" << ": " <<
//     fTextSpannerWithCenteredTextIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fMergeMultiMeasureRestsIsNeeded" << ": " <<
//     fMergeMultiMeasureRestsIsNeeded <<
//     std::endl <<
//
//     std::setw (fieldWidth) <<
//     "fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded" << ": " <<
//     fBarNumberEveryNAndAtTheBeginningOfLinesIsNeeded <<
//     std::endl << std::endl;

  os <<
    "LPSR basic information" <<
    std::endl << std::endl;

  ++gIndenter;

  // print LPSR basic information
  fScoreHeader->print (os);
  os << std::endl;

  fScorePaper->print (os);
  os << std::endl;

  if (fScoreLayout) {
    fScoreLayout->print (os);
    os << std::endl;
  }

  --gIndenter;

  // print the voices and stanzas
  if (fScoreElementsList.size ()) {
    os <<
      "Voices & Stanzas" <<
      std::endl << std::endl;

    ++gIndenter;

    std::list<S_msrElement>::const_iterator
      iBegin = fScoreElementsList.begin (),
      iEnd   = fScoreElementsList.end (),
      i      = iBegin;
    for ( ; ; ) {
      (*i)->print (os);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  // print the book blocks
  if (fScoreBookBlocksList.size ()) {
    os <<
      "Book blocks" <<
      std::endl << std::endl;
    ++gIndenter;

    std::list<S_lpsrBookBlock>::const_iterator
      iBegin = fScoreBookBlocksList.begin (),
      iEnd   = fScoreBookBlocksList.end (),
      i      = iBegin;
    for ( ; ; ) {
      (*i)->print (os);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  --gIndenter;
}

void lpsrScore::print (std::ostream& os) const
{
  os <<
    "LPSR Score, short version" <<
    std::endl << std::endl;

#ifdef MF_SANITY_CHECKS_ARE_ENABLED
  // sanity check
  mfAssert (
    __FILE__, __LINE__,
    fEmbeddedMsrScore != nullptr,
    "fEmbeddedMsrScore is null");
#endif // MF_SANITY_CHECKS_ARE_ENABLED

  ++gIndenter;

  // print the MSR embedded score (without the voices)
  os << fEmbeddedMsrScore;
  os << std::endl;

  os <<
    "LPSR basic information" <<
    std::endl << std::endl;

  ++gIndenter;

  // print LPSR basic information
  os << fScoreHeader;
  os << std::endl;

  os << fScorePaper;
  os << std::endl;

  if (fScoreLayout) {
    os << fScoreLayout;
    os << std::endl;
  }

  --gIndenter;

  // print the voices and stanzas
  if (fScoreElementsList.size ()) {
    os <<
      "Voices & Stanzas" <<
      std::endl << std::endl;

    ++gIndenter;

    std::list<S_msrElement>::const_iterator
      iBegin = fScoreElementsList.begin (),
      iEnd   = fScoreElementsList.end (),
      i      = iBegin;
    for ( ; ; ) {
      os << (*i);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  // print the book blocks
  if (fScoreBookBlocksList.size ()) {
    os <<
      "Book blocks" <<
      std::endl << std::endl;
    ++gIndenter;

    std::list<S_lpsrBookBlock>::const_iterator
      iBegin = fScoreBookBlocksList.begin (),
      iEnd   = fScoreBookBlocksList.end (),
      i      = iBegin;
    for ( ; ; ) {
      os << (*i);
      if (++i == iEnd) break;
      os << std::endl;
    } // for

    os << std::endl;
    --gIndenter;
  }

  --gIndenter;
}

std::ostream& operator << (std::ostream& os, const S_lpsrScore& scr)
{
  scr->print (os);
  return os;
}


}
