% !TEX root = MusicFormatsMaintainanceGuide.tex

% -------------------------------------------------------------------------
\chapter{Textual input and output}
% -------------------------------------------------------------------------

%%%%JMI All XML text input is done by building an \mxsrRepr, using a parser provided by \libmusicxml. MSDL input is done by in \msdlToMsrBoth{msdlScanner}.


% -------------------------------------------------------------------------
\section{Indented output streams}
% -------------------------------------------------------------------------

To meet the need of indented output to produce , we got inspiration from \url{https://stackoverflow.com/questions/2212776/overload-handling-of-stdendl}.

This leads to class {\tt mfIndentedOstream}, defined in \mfutilitiesBoth{mfIndentedTextOutput}:
\begin{lstlisting}[language=CPlusPlus]
class EXP mfIndentedOstream: public ostream, public smartable
\end{lstlisting}

The key to this lies in thw overloaded \method{mfIndentedStreamBuf}{sync}:
\begin{lstlisting}[language=CPlusPlus]
//______________________________________________________________________________
int mfIndentedStreamBuf::sync ()
{
  // When we sync the stream with fOutputSteam:
  // 1) output the indentation then the buffer
  // 2) reset the buffer
  // 3) flush the actual output stream we are using.

  unsigned int strSize = str ().size ();

  // fetch the last non-space character in the buffer
  // caution: the '\n' is present as the last character!
  size_t found = str ().find_last_not_of (' ', strSize - 2);

  // this can be uncommented to see low level informations
  // fOutputSteam << "% strSize: " << strSize << ", found: " << found << '\n';

  // output the indenter
  fOutputSteam << fOutputIndenter;

  // output the buffer
  if (found == strSize - 3) {
    // don't output the trailing spaces, but output the end of line
    fOutputSteam << str ().substr (0, found + 1) << '\n';
  }
  else {
    // output the whole buffer
    fOutputSteam << str ();
  }

  // reset the buffer
  str ("");

  // flush the output stream
  fOutputSteam.flush ();

  return 0;
}
\end{lstlisting}

Such indented output streams are used for nearly all of the output produced by \mf, except for Braille which follows its own rules for indentation of cell lines.


% -------------------------------------------------------------------------
\section{Creating indented output streams}
% -------------------------------------------------------------------------

Such indented output streams are passed by reference to various methods which only know of {\tt osstream}, among them:
\begin{lstlisting}[language=CPlusPlus]
    void                  print (ostream& os) const override;
\end{lstlisting}

All those methods manipulate {\tt mfIndentedOstream} instances seamlessly, not knowing their actual type.
This is needed for the use of \mf\ by applications through the \API\ and not as an service. In particular, \Web\ sites also know only of regular output streams.

So when and where are {\tt mfIndentedOstream} instances created?

\Function{translateLpsrToLilypondWithHandler}, in \lpsrToLilypond{lpsr2lilypondInterface.cpp}, creates one depending on wether it writes the \lily\ code to standard output of to a file.

The parameters to this function\index{functions} are:
\begin{lstlisting}[language=CPlusPlus]
EXP void translateLpsrToLilypondWithHandler (
  const S_lpsrScore theLpsrScore,
  S_msrOahGroup     msrOpts,
  S_lpsrOahGroup    lpsrOpts,
  const string&     passNumber,
  const string&     passDescription,
  S_oahHandler      handler,
  ostream&          out,
  ostream&          err)
\end{lstlisting}

In order to have a global current indentation, \mf\ uses \globalVariable{gIndenter}, because it should otherwise passed over to many methods throughout the code base. It is defined in \mfutilities{mfIndentedTextOutput.h}:
\begin{lstlisting}[language=CPlusPlus]
#define gIndenter mfOutputIndenter::gGlobalOStreamIndenter
\end{lstlisting}

When writing to standard output, the indented output stream is constructed above the caller-supplied {\tt out}:
\begin{lstlisting}[language=CPlusPlus]
    // create an indented output stream for the LilyPond code
    // to be written to outputFileStream
    mfIndentedOstream
      lilypondStandardOutputStream (
        out,
        gIndenter);

    // convert the LPSR score to LilyPond code
    try {
      translateLpsrToLilypond (
        theLpsrScore,
        gGlobalMsrOahGroup,
        gGlobalLpsrOahGroup,
        passNumber,
        passDescription,
        lilypondStandardOutputStream);
    }
\end{lstlisting}

When writing to a file, an {\tt ofstream} is instantiated to write to the file given by its name, and the indented output stream is constructed above the latter:
\begin{lstlisting}[language=CPlusPlus]
     ofstream
      outputFileStream (
        outputFileName.c_str (),
        ofstream::out);

    // create an indented output stream for the LilyPond code
    // to be written to outputFileStream
    mfIndentedOstream
      lilypondFileOutputStream (
        outputFileStream,
        gIndenter);

    // convert the LPSR score to LilyPond code
    try {
      translateLpsrToLilypond (
        theLpsrScore,
        gGlobalMsrOahGroup,
        gGlobalLpsrOahGroup,
        passNumber,
        passDescription,
        lilypondFileOutputStream);
    }
\end{lstlisting}

The code that uses \mf\ thus does not have to care for indented streams instantiation: this is done behind the scene by the library.


% -------------------------------------------------------------------------
\section{Indenting the output}
% -------------------------------------------------------------------------

Indenting the output is handled with a single variable defined in \mfutilities{mfIndentedTextOutput.h}.
This sharing of a global variable is needed to produce orderly output, since many parts of the \mf\ library can contribute to it:
\begin{lstlisting}[language=CPlusPlus]
// useful shortcut macros
#define gIndenter mfOutputIndenter::gGlobalOStreamIndenter
#define gTab      mfOutputIndenter::gGlobalOStreamIndenter.getSpacer ()
\end{lstlisting}

A typical sequence to produce indented output is:
\begin{lstlisting}[language=CPlusPlus]
void msrTranspose::print (ostream& os) const
{
  const int fieldWidth = 22;

  os <<
    "Transpose" <<
    ", line " << fInputLineNumber <<
    endl;

  ++gIndenter;

  os << left <<
    setw (fieldWidth) <<
    "transposeDiatonic" << " = " << fTransposeDiatonic <<
    endl <<
    setw (fieldWidth) <<
    "transposeChromatic" << " = " << fTransposeChromatic <<
    endl <<
    setw (fieldWidth) <<
    "transposeOctaveChange" << " = " << fTransposeOctaveChange <<
    endl <<
    setw (fieldWidth) <<
    "transposeDouble" << " = " << fTransposeDouble <<
    endl << endl;

  --gIndenter;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Printing descriptions}
% -------------------------------------------------------------------------

There is a standard set of methods to print the contents of the descriptions in \mf\ to standard output, depending on the granularity of the information to be displayed:
\begin{lstlisting}[language=CPlusPlus]
    void                  print (ostream& os) const override;

    string                asString () const override;
    string                asStringShort () const override;
\end{lstlisting}

There are also more specific methods such as:
\begin{lstlisting}[language=CPlusPlus]
    void                  printShort (ostream& os) const override;

    void                  printSummary (ostream& os) const override;
\end{lstlisting}

Note that:
\begin{itemize}
\item \virtualMethod{asString} produces a rather condensed view of the data to be displayed as part of a single line;
\item \virtualMethod{print} may produce its output on multiples lines, which always ends with an end of line.
\end{itemize}

Most classes in \mf\ can be printed with the {\tt <<} operator:
\begin{lstlisting}[language=CPlusPlus]
ostream& operator<< (ostream& os, const S_msrElement& elt)
{
  elt->print (os);
  return os;
}
\end{lstlisting}

In simple cases, \virtualMethod{print} merely calls \virtualMethod{asString}:
\begin{lstlisting}[language=CPlusPlus]
void msrElement::print (ostream& os) const
{
  os << asString () << endl;
}
\end{lstlisting}

All \methodName{asString} methods produce an output of the form {\tt [...]}, in order to facilitate selecting the whole with a double click to help the user, since such output can be nested:
\begin{lstlisting}[language=CPlusPlus]
string msrTranspose::asString () const
{
  stringstream s;

  s <<
    "[Transpose" <<
    ", diatonic = " << fTransposeDiatonic <<
    ", chromatic = " << fTransposeChromatic <<
    ", transposeOctaveChange = " << fTransposeOctaveChange <<
    ", transposeDouble = " << fTransposeDouble <<
    ", line " << fInputLineNumber <<
    "]";

  return s.str ();
}
\end{lstlisting}

A typical sequence to produce indented output is:
\begin{lstlisting}[language=CPlusPlus]
void msrTranspose::print (ostream& os) const
{
  const int fieldWidth = 22;

  os <<
    "Transpose" <<
    ", line " << fInputLineNumber <<
    endl;

  ++gIndenter;

  os << left <<
    setw (fieldWidth) <<
    "transposeDiatonic" << " = " << fTransposeDiatonic <<
    endl <<
    setw (fieldWidth) <<
    "transposeChromatic" << " = " << fTransposeChromatic <<
    endl <<
    setw (fieldWidth) <<
    "transposeOctaveChange" << " = " << fTransposeOctaveChange <<
    endl <<
    setw (fieldWidth) <<
    "transposeDouble" << " = " << fTransposeDouble <<
    endl << endl;

  --gIndenter;
}
\end{lstlisting}

The main indented output streams are:
\begin{lstlisting}[language=CPlusPlus]
#define gOutputStream *gGlobalOutputIndentedOstream
#define gLogStream    *gGlobalLogIndentedOstream

\end{lstlisting}


