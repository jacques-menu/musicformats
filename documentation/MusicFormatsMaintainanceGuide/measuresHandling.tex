% !TEX root = MusicFormatsMaintainanceGuide.tex

% -------------------------------------------------------------------------
\chapter{Measures handling}\label{Measures handling}
% -------------------------------------------------------------------------

Measures are presented at \sectionRef{Measures}.


% -------------------------------------------------------------------------
\section{Voices contents}
% -------------------------------------------------------------------------

\Class{msrVoice} contain a list of the first elements and a last segment:
\begin{lstlisting}[language=CPlusPlus]
    list<S_msrVoiceElement>
                          fVoiceInitialElementsList;

    // fVoiceLastSegment contains the music
    // not yet stored in fVoiceInitialElementsList,
    // it is thus logically the end of the latter,
    // and is created implicitly for every voice.
    // It is needed 'outside' of the 'list<S_msrElement>'
    // because it is not a mere S_msrElement, but a S_msrSegment
    S_msrSegment          fVoiceLastSegment;
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Voice elements}
% -------------------------------------------------------------------------

The \class{msrVoiceElement} subclasses instances in {\tt fVoiceInitialElementsList} can be of types:
\begin{lstlisting}[language=Terminal]
jacquesmenu@macmini: ~/musicformats-git-dev/src > grep 'public msrVoiceElement' formats/msr/*.h
formats/msr/msrBeatRepeats.h:class EXP msrBeatRepeat : public msrVoiceElement
formats/msr/msrMeasureRepeats.h:class EXP msrMeasureRepeat : public msrVoiceElement
formats/msr/msrRepeats.h:class EXP msrRepeat : public msrVoiceElement
formats/msr/msrMultipleFullBarRests.h:class EXP msrMultipleFullBarRests : public msrVoiceElement
formats/msr/msrSegments.h:class EXP msrSegment : public msrVoiceElement
\end{lstlisting}

\Class{msrSegment} contains a list of measures:
\begin{lstlisting}[language=CPlusPlus]
    // the measures in the segment contain the mmusic
    list<S_msrMeasure>    fSegmentElementsList;
\end{lstlisting}

Class {\tt } contains a list of mesure elements:
\begin{lstlisting}[language=CPlusPlus]
    // elements

    list<S_msrMeasureElement>
                          fMeasureElementsList;
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Measure elements}
% -------------------------------------------------------------------------

The \class{msrMeasureElements} subclasses instances in {\tt } can be of types:
\begin{lstlisting}[language=Terminal]
jacquesmenu@macmini: ~/musicformats-git-dev/src/formats/msr > grep 'public msrMeasureElement' *.h
msrBarChecks.h:class EXP msrBarCheck : public msrMeasureElement
msrBarLines.h:class EXP msrBarLine : public msrMeasureElement
msrBarNumberChecks.h:class EXP msrBarNumberCheck : public msrMeasureElement
msrBreaks.h:class EXP msrLineBreak : public msrMeasureElement
msrBreaks.h:class EXP msrPageBreak : public msrMeasureElement
msrClefs.h:class EXP msrClef : public msrMeasureElement
msrCodas.h:class EXP msrCoda : public msrMeasureElement
msrDoubleTremolos.h:class EXP msrDoubleTremolo : public msrMeasureElement
msrEyeGlasses.h:class EXP msrEyeGlasses : public msrMeasureElement
msrFiguredBassElements.h:class EXP msrFiguredBassElement : public msrMeasureElement
msrHarmonies.h:class EXP msrHarmony : public msrMeasureElement
msrHiddenMeasureAndBarLines.h:class EXP msrHiddenMeasureAndBarLine : public msrMeasureElement
msrInstruments.h:class EXP msrScordatura : public msrMeasureElement
msrInstruments.h:class EXP msrAccordionRegistration : public msrMeasureElement
msrInstruments.h:class EXP msrHarpPedalsTuning : public msrMeasureElement
msrInstruments.h:class EXP msrPedal : public msrMeasureElement
msrInstruments.h:class EXP msrDamp : public msrMeasureElement
msrInstruments.h:class EXP msrDampAll : public msrMeasureElement
msrKeys.h:class EXP msrKey : public msrMeasureElement
msrLyrics.h:class EXP msrSyllable : public msrMeasureElement
msrMusicXMLSpecifics.h:class EXP msrPrintLayout : public msrMeasureElement
msrRehearsalMarks.h:class EXP msrRehearsalMark : public msrMeasureElement
msrSegnos.h:class EXP msrSegno : public msrMeasureElement
msrSegnos.h:class EXP msrDalSegno : public msrMeasureElement
msrStavesDetails.h:class EXP msrStaffDetails : public msrMeasureElement
msrTempos.h:class EXP msrTempo : public msrMeasureElement
msrTimeSignatures.h:class EXP msrTimeSignature : public msrMeasureElement
msrTranspositions.h:class EXP msrOctaveShift : public msrMeasureElement
msrTranspositions.h:class EXP msrTransposition : public msrMeasureElement
msrTupletElements.h:class EXP msrTupletElement : public msrMeasureElement
msrVoiceStaffChanges.h:class EXP msrVoiceStaffChange : public msrMeasureElement
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Appending measure elements to a measure}
% -------------------------------------------------------------------------

Appending music elements to a measure is done by \method{msrMeasure}{appendElementToMeasure}, defined in \msrBoth{msrMeasures}:%%%JMI
\begin{lstlisting}[language=CPlusPlus]
void msrMeasure::appendElementToMeasure (S_msrMeasureElement elem)
{
  int inputLineNumber =
    elem->getInputLineNumber ();

#ifdef TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceMeasures ()) {
    gLogStream <<
      "Appending element " <<
      elem->asShortString () <<
      " to measure " <<
      asShortString () <<
      " in voice \"" <<
      fetchMeasureVoiceUpLink ()->
        getVoiceName () <<
      "\", currentMeasureWholeNotesDuration = " <<
      fCurrentMeasureWholeNotesDuration <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // set elem's measure number
  elem->
    setMeasureElementMeasureNumber (
      fMeasureElementMeasureNumber);

  // set elem's position in measure
  elem->
    setMeasureElementPositionInMeasure (
      fCurrentMeasureWholeNotesDuration,
      "appendElementToMeasure()");

  fMeasureElementsList.push_back (elem);

  // take elem's sounding whole notes into account JMI ???
if (false) // JMI CAFE
  incrementCurrentMeasureWholeNotesDuration (
    inputLineNumber,
    elem->
      getMeasureElementSoundingWholeNotes ());
}
\end{lstlisting}

Here is how a harmony instance is appended to a measure:
\begin{lstlisting}[language=CPlusPlus]
void msrMeasure::appendHarmonyToMeasure (S_msrHarmony harmony)
{
  int inputLineNumber =
    harmony->getInputLineNumber ();

#ifdef TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceHarmonies ()) {
    gLogStream <<
      "Appending harmony " << harmony->asString () <<
      " to measure " <<
      this->asShortString () <<
      " in segment '" <<
      fMeasureSegmentUpLink->getSegmentAbsoluteNumber () <<
      "' in voice \"" <<
      fMeasureSegmentUpLink->
        getSegmentVoiceUpLink ()->
          getVoiceName () <<
      "\", currentMeasureWholeNotesDuration = " <<
      fCurrentMeasureWholeNotesDuration <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  // set harmony's measure number
  harmony->
    setMeasureElementMeasureNumber (
      fMeasureElementMeasureNumber);

  // append the harmony to the measure elements list
  // DON'T call 'appendElementToMeasure (harmony)':
  // that would override harmony's position in measure,
  // which already has the correct value, thus:
  fMeasureElementsList.push_back (harmony);

  // get harmony sounding whole notes
  rational
    harmonySoundingWholeNotes =
      harmony->
        getHarmonySoundingWholeNotes ();

  // account for harmony duration in measure whole notes
  incrementCurrentMeasureWholeNotesDuration (
    inputLineNumber,
    harmonySoundingWholeNotes);

  // this measure contains music
  fMeasureContainsMusic = true;
}
\end{lstlisting}

The task is simpler when appending a harmony to a measure clone, because the clone's harmony's measure number comes from the clone's original:
\begin{lstlisting}[language=CPlusPlus]
void msrMeasure::appendHarmonyToMeasureClone (S_msrHarmony harmony)
{
  int inputLineNumber =
    harmony->getInputLineNumber ();

#ifdef TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceHarmonies ()) {
    gLogStream <<
      "Appending harmony " << harmony->asString () <<
      " to measure clone " <<
      this->asShortString () <<
      " in segment clone '" <<
      fMeasureSegmentUpLink->getSegmentAbsoluteNumber () <<
      "' in voice clone \"" <<
      fMeasureSegmentUpLink->
        getSegmentVoiceUpLink ()->
          getVoiceName () <<
      "\", currentMeasureWholeNotesDuration = " <<
      fCurrentMeasureWholeNotesDuration <<
      ", line " << inputLineNumber <<
      endl;
  }
#endif

  ++gIndenter;

  // append the harmony to the measure elements list
  appendElementToMeasure (harmony);

  // fetch harmony sounding whole notes
  rational
    harmonySoundingWholeNotes =
      harmony->
        getHarmonySoundingWholeNotes ();

  // account for harmony duration in measure whole notes
  incrementCurrentMeasureWholeNotesDuration (
    inputLineNumber,
    harmonySoundingWholeNotes);

  // this measure contains music
  fMeasureContainsMusic = true;

  --gIndenter;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Appending measures to a segment}
% -------------------------------------------------------------------------

Measures are appended to a segment by \method{msrSegment}{appendMeasureToSegment} in \\\msrBoth{msrSegments}:
\begin{lstlisting}[language=CPlusPlus]
void msrSegment::appendMeasureToSegment (S_msrMeasure measure)
{
  int inputLineNumber =
    measure->getInputLineNumber ();

  string measureNumber =
    measure->getMeasureElementMeasureNumber ();

  unsigned int segmentElementsListSize =
    fSegmentElementsList.size ();

  string currentMeasureNumber =
    segmentElementsListSize == 0
      ? ""
      : fSegmentElementsList.back ()->getMeasureElementMeasureNumber ();

#ifdef TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceMeasures ()) {
    gLogStream <<
      "Appending measure '" << measureNumber <<
      "' to segment " << asString ();

    if (fSegmentElementsList.size () == 0)
      gLogStream <<
        ", as first measure";
    else
      gLogStream <<
      ", after measure number '" << currentMeasureNumber << "'";

    gLogStream <<
      "' in voice \"" <<
      fSegmentVoiceUpLink->getVoiceName () <<
      "\"" <<
      ", line " << measure->getInputLineNumber () <<
      endl;
  }
#endif

  if (measureNumber == currentMeasureNumber) {
    stringstream s;

    s <<
      "appending measure number '" << measureNumber <<
      "' occurs twice in a row in segment " <<
      asString () <<
      " in voice \"" <<
      fSegmentVoiceUpLink->getVoiceName () <<
      "\"";

//    msrInternalWarning ( // JMI
    msrInternalError (
      gGlobalServiceRunData->getInputSourceName (),
      inputLineNumber,
      __FILE__, __LINE__,
      s.str ());
  }

  // is measure the first one this segment?
  if (segmentElementsListSize == 0) {
    measure->
      setMeasureFirstInSegmentKind (
        msrMeasure::kMeasureFirstInSegmentKindYes);
  }
  else {
    measure->
      setMeasureFirstInSegmentKind (
        msrMeasure::kMeasureFirstInSegmentKindNo);
  }

  // is measure the first one it the voice?
  // this is necessary for voice clones,
  // which don't go down the part-staff-voice-segment hierarchy
  if (! fSegmentVoiceUpLink->getVoiceFirstMeasure ()) {
    // yes, register it as such
    fSegmentVoiceUpLink->
      setVoiceFirstMeasure (measure);

    measure->
      setMeasureFirstInVoice ();
  }

  // append measure to the segment
  fSegmentElementsList.push_back (measure);
}
\end{lstlisting}

Calls to \method{msrSegment}{appendMeasureToSegment} occur in:
\begin{itemize}
\item \method{msrSegment}{createAMeasureAndAppendItToSegment} called from:\bigskip\\
			\indentedBox[1.5cm]{
				\method{msrVoice}{createAMeasureAndAppendItToVoice}
			}

\item \method{msrVoice}{appendMeasureCloneToVoiceClone} called from:\bigskip\\%%%JMI \visitorMethod{msr2lpsrTranslator}{visitStart (S_msrMeasure\& elt), commented
			\visitorMethod{msr2msrTranslator}{visitStart (S_msrMeasure\& elt)}
			\indentedBox{
			}

\item \method{msrMultipleFullBarRests}{appendMeasureCloneToMultipleFullBarRests} called from:\bigskip\\%%% \\visitorMethod{msr2lpsrTranslator}{visitStart (S_msrMeasure\& elt) commented
			\indentedBox{
  			\visitorMethod{msr2msrTranslator}{visitStart (S_msrMeasure\& elt)}
			}

\item \method{msrVoice}{appendMeasureCloneToVoiceClone} called from:\bigskip\\%%%JMI \\visitorMethod{msr2lpsrTranslator}{visitStart (S_msrMeasure\& elt)
			\indentedBox{
  			\visitorMethod{msr2lpsrTranslator}{visitStart (S_msrMeasure\& elt)}
			}

\item \method{msrVoice}{createNewLastSegmentFromItsFirstMeasureForVoice} called from:\bigskip\\%%%JMI \method{msrVoice}{addEmptyMeasuresToVoice} commented
			\indentedBox{
  			\method{msrVoice}{handleVoiceLevelRepeatStart},\\
  			\method{msrVoice}{handleVoiceLevelRepeatEndingStartWithoutExplicitStart},\\
  			\method{msrVoice}{handleVoiceLevelRepeatEndingStartWithExplicitStart},\\
  			\method{msrVoice}{createMeasureRepeatFromItsFirstMeasures},\\
  			\method{msrVoice}{appendPendingMeasureRepeatToVoice},\\
  			\method{msrVoice}{createMultipleFullBarRestsInVoice}
			}

\end{itemize}


% -------------------------------------------------------------------------
\section{Appending measures to a voice}
% -------------------------------------------------------------------------

%All music elements appended to a voice are actually appended to its last segment:

\Method{msrVoice}{appendMeasureCloneToVoiceClone} does the job in \msrBoth{msrVoices}.


\begin{lstlisting}[language=CPlusPlus]
S_msrMeasure msrVoice::createAMeasureAndAppendItToVoice (
  int    inputLineNumber,
  string measureNumber,
  msrMeasureImplicitKind
         measureImplicitKind)
{
  fVoiceCurrentMeasureNumber = measureNumber;

#ifdef TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceMeasures ()) {
    gLogStream <<
      "Creating measure '" <<
      measureNumber <<
      "' and appending it to voice \"" << getVoiceName () << "\"" <<
      "', line " << inputLineNumber <<
      endl;
  }
#endif

  fCallsCounter++;

  if (
//     true
//       ||
    false
      &&
    (
      fCallsCounter == 2 && getVoiceName ()
        ==
      "Part_POne_HARMONIES_Staff_Voice_Eleven_HARMONIES"
    )
  ) { // POUSSE JMI
    gLogStream <<
      endl <<
      "++++ createAMeasureAndAppendItToVoice() POUSSE, fCallsCounter: " << fCallsCounter << " ++++" <<
      endl;
    this->print (gLogStream);
    gLogStream <<
      endl;
  }

#ifdef TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceMeasuresDetails ()) {
    displayVoice (
      inputLineNumber,
      "createAMeasureAndAppendItToVoice() 1");
  }
#endif

  ++gIndenter;

  // create the voice last segment if needed
  if (! fVoiceLastSegment) {
    createNewLastSegmentForVoice (
      inputLineNumber,
      "createAMeasureAndAppendItToVoice() 2");
  }

  // append a new measure with given number to voice last segment
  S_msrMeasure
    result =
      fVoiceLastSegment->
        createAMeasureAndAppendItToSegment (
          inputLineNumber,
          measureNumber,
          measureImplicitKind);

  // result is the new voice last appended measure
  fVoiceLastAppendedMeasure = result;

#ifdef TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceMeasuresDetails ()) {
    displayVoice (
      inputLineNumber,
      "createAMeasureAndAppendItToVoice() 3");
  }
#endif

  --gIndenter;

  return result;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Translating from MXSR to MSR}
% -------------------------------------------------------------------------

This is done in \mxsrToMsr{}.

Upon the first visit of {\tt S_measure}, as \class{msrMeasure} instance is created and append to the current part:
\begin{lstlisting}[language=CPlusPlus]
void mxsr2msrTranslator::visitStart (S_measure& elt)
{
	// ... ... ...

  // take this measure into account
  ++fPartMeasuresCounter;

	// ... ... ...

  // implicit

/*
  Measures with an implicit attribute set to "yes"
  never display a measure number,
  regardless of the measure-numbering setting.
  *
  The implicit attribute is set to "yes" for measures where
  the measure number should never appear, such as pickup
  measures and the last half of mid-measure repeats. The
  value is "no" if not specified.
*/

  string
    implicit =
      elt->getAttributeValue ("implicit");

  msrMeasureImplicitKind
    measureImplicitKind =
      msrMeasureImplicitKind::kMeasureImplicitKindNo; // default value

  if       (implicit == "yes") {
    measureImplicitKind =
      msrMeasureImplicitKind::kMeasureImplicitKindYes;
  }
  else  if (implicit == "no") {
    measureImplicitKind =
      msrMeasureImplicitKind::kMeasureImplicitKindNo;
  }
  else {
    if (implicit.size ()) {
      stringstream s;

      s <<
        "implicit \"" << implicit <<
        "\" is unknown";

      musicxmlError (
        gGlobalServiceRunData->getInputSourceName (),
        inputLineNumber,
        __FILE__, __LINE__,
        s.str ());
    }
  }

  // append a new measure to the current part
  fCurrentPart->
    createAMeasureAndAppendItToPart (
      inputLineNumber,
      fCurrentMeasureNumber,
      measureImplicitKind);

	// ... ... ...
}
\end{lstlisting}

Upon the second visit of {\tt S_measure}, the last appended measure appended to the current part is finalized:
\begin{lstlisting}[language=CPlusPlus]
void mxsr2msrTranslator::visitEnd (S_measure& elt)
{
	// ... ... ...

  // finalize current measure in the part,
  // to add skips if necessary and set measure kind
  fCurrentPart->
    finalizeLastAppendedMeasureInPart (
      inputLineNumber);

	// ... ... ...
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Translating from MXSR to MSR}
% -------------------------------------------------------------------------

A new \class{msrMeasure} instance is created in \mxsrToMsr{mxsr2msrTranslator.cpp} upon the first visit of {\tt S_measure}:
\begin{lstlisting}[language=CPlusPlus]
//________________________________________________________________________
void mxsr2msrTranslator::visitStart (S_measure& elt)
{
	// ... ... ...

  // append a new measure to the current part
  fCurrentPart->
    createAMeasureAndAppendItToPart (
      inputLineNumber,
      fCurrentMeasureNumber,
      measureImplicitKind);

	// ... ... ...
}
\end{lstlisting}

This can lead to several \class{msrMeasure} instances being created, depending on the \mxml\ data. Hence there is no notion of a current measure in this translator.

\Method{msrPart}{createAMeasureAndAppendItToPart} creates and appends a measure to the part harmonies and figured bass staves if relevant, and then \cascade\ s to the part staves:
\begin{lstlisting}[language=CPlusPlus]
void msrPart::createAMeasureAndAppendItToPart (
  int    inputLineNumber,
  string measureNumber,
  msrMeasureImplicitKind
         measureImplicitKind)
{
	// ... ... ...

  // set part current measure number
  fPartCurrentMeasureNumber = measureNumber;

  // create and append measure in all the staves
  for (S_msrStaff staff : fPartAllStavesList) {
    staff->
      createAMeasureAndAppendItToStaff (
        inputLineNumber,
        measureNumber,
        measureImplicitKind);
  } // for

	// ... ... ...
\end{lstlisting}



% -------------------------------------------------------------------------
\section{Translating from MSR to MSR}
% -------------------------------------------------------------------------

This is done in \msrToMsr{}.


% -------------------------------------------------------------------------
\section{Translating from MSR to LPSR}
% -------------------------------------------------------------------------

This is done in \msrToLpsr{}.


% -------------------------------------------------------------------------
\section{Translating from LPSR to LilyPond}
% -------------------------------------------------------------------------

This is done in \lpsrToLilypond{}.


