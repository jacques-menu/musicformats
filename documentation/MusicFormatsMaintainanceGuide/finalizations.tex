% !TEX root = MusicFormatsMaintainanceGuide.tex

% -------------------------------------------------------------------------
\chapter{Finalizations}
% -------------------------------------------------------------------------

% -------------------------------------------------------------------------
\section{Clones vs non-clones finalization}
% -------------------------------------------------------------------------

Finalizing clones may be simpler that finalizing a just-created and populated non-clone, due to the information available in the clone's original.

For example, \method{msrMeasure}{finalizeMeasure} delegates part of the job to methods handling the three kinds of voices, respectively:
\begin{lstlisting}[language=CPlusPlus]
void msrMeasure::finalizeMeasure (
  int                          inputLineNumber,
  msrMeasureRepeatContextKind measureRepeatContextKind,
  std::string        context)
{
	// ... ... ...

    S_msrVoice
      voice =
        fMeasureUpLinkToSegment->
          getSegmentUpLinkToVoice ();

	// ... ... ...

    // delegate to voice kind specific methods
    switch (voice->getVoiceKind ()) {
      case msrVoiceKind::kVoiceKindRegular:
        finalizeRegularMeasure (
          inputLineNumber,
          measureRepeatContextKind,
          context);
        break;

      case msrVoiceKind::kVoiceKindDynamics:
        break;

      case msrVoiceKind::kVoiceKindHarmonies:
        finalizeHarmonyMeasure (
          inputLineNumber,
          measureRepeatContextKind,
          context);
        break;

      case msrVoiceKind::kVoiceKindFiguredBass:
        finalizeFiguredBassMeasure (
          inputLineNumber,
          measureRepeatContextKind,
          context);
        break;
    } // switch

	// ... ... ...
}
\end{lstlisting}

In the case of harmony and figured bass voices, padding may have to be added to obtain a complete measure. This does not happen for clones of such voices: the padding skips are in the original voice and will be visited and handled without anything special to be done.


% -------------------------------------------------------------------------
\section{The finalization methods}
% -------------------------------------------------------------------------

There is a set of \virtualMethod{finalize*} methods in \mf. There basic ones are:
\begin{itemize}
\item \method{msrPart}{finalizePart} and \method{msrPart}{finalizePartClone},\\
		  defined in \msrBoth{msrParts}
\item \method{msrStaff}{finalizeStaff},\\
		  defined in \msrBoth{msrStaves}
\item \method{msrVoice}{finalizeVoice},\\
		  defined in \msrBoth{msrVoices}\\[-0.5ex]

\item \method{msrSegment}{finalizeAllTheMeasuresOfSegment},\\
		  defined in \msrBoth{msrSegments}\\[-0.5ex]

\item \method{msrMeasure}{finalizeMeasure}, \method{msrMeasure}{finalizeMeasureClone} and \method{msrMeasure}{finalizeRegularMeasure},\\
		  defined in \msrBoth{msrMeasures}\\[-0.5ex]

\item \method{msrChord}{finalizeChord},\\
		  defined in \msrBoth{msrChords}\\[-0.5ex]

\item \method{msrTuplets}{finalizeTuplet},\\
		  defined in \msrBoth{msrTuplets}
\item \method{mxsr2msrTranslator}{finalizeTupletAndPopItFromTupletsStack}, \\
      defined in \mxsrToMsrBoth{mxsr2msrTranslator.h}\\[-0.5ex]

\item \method{msrMeasure}{finalizeFiguredBassMeasure},\\
		  defined in \msrBoth{msrMeasures}
\item \method{msrMeasure}{finalizeHarmonyMeasure},\\
		  defined in \msrBoth{msrMeasures}\\[-0.5ex]


\item \method{msr2bsrTranslator}{finalizeCurrentMeasureClone},\\
		  defined in \msrToBsrBoth(msr2bsrTranslator)\\[-0.5ex]

\item \method{mxsr2msrTranslator}{finalizeCurrentChord},\\
		  defined in \mxsrToMsrBoth{mxsr2msrTranslator}
\end{itemize}

Handling repeats is rather complex in \mf. Repeat ends are finalized with these methods:
\begin{itemize}
\item \method{msrPart}{finalizeRepeatEndInPart},\\
		  defined in \msrBoth{msrParts}
\item \method{msrStaff}{finalizeRepeatEndInStaff},\\
		  defined in \msrBoth{msrStaves}
\item \method{msrVoice}{finalizeRepeatEndInVoice},\\
		  defined in \msrBoth{msrVoices}
\end{itemize}

\newpage

There are also '\cascading' finalization methods: they propagate finalization going from \class{msrPart} towards \class{msrVoice}:
\begin{itemize}
\item \method{msrPart}{finalizeLastAppendedMeasureInPart},\\
		  defined in \msrBoth{msrParts}
\item \method{msrStaff}{finalizeLastAppendedMeasureInStaff},\\
		  defined in \msrBoth{msrStaves}
\item \method{msrVoice}{finalizeLastAppendedMeasureInVoice},\\
		  defined in \msrBoth{msrVoices}\\[-0.5ex]

\item \method{msrPart}{finalizePartAndAllItsMeasures},\\
		  defined in \msrBoth{msrParts}
\item \method{msrVoice}{finalizeVoiceAndAllItsMeasures},\\
		  defined in \msrBoth{msrVoices}
\end{itemize}

A typical example of \cascading finalization is \method{msrPart}{finalizePartAndAllItsMeasures}:
\begin{lstlisting}[language=CPlusPlus]
void msrPart::finalizePartAndAllItsMeasures (
  int inputLineNumber)
{
#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceParts ()) {
    gLogStream <<
      "Finalizing part clone " <<
      getPartCombinedName () <<
      ", line " << inputLineNumber <<
      std::endl;
  }
#endif

#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceVoices ()) {
    gLogStream <<
      "Finalizing all the measures of part \"" <<
      getPartCombinedName () <<
      "\", line " << inputLineNumber <<
      std::endl;
  }
#endif

  for (
    std::list<S_msrVoice>::const_iterator i = fPartAllVoicesList.begin ();
    i != fPartAllVoicesList.end ();
    ++i
  ) {
    const S_msrVoice& voice = (*i);

    voice->
      finalizeVoiceAndAllItsMeasures (
        inputLineNumber);
  } // for

  // collect the part measures slices from the staves
  collectPartMeasuresSlices (
    inputLineNumber);
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Finalizing parts}
% -------------------------------------------------------------------------

\Method{msrPart}{finalizePart} warns if there are no staves in the part, and otherwise handles them, including \cascading to \method{msrStaff}{finalizeStaff}:
\begin{lstlisting}[language=CPlusPlus]
void msrPart::finalizePart (
  int inputLineNumber)
{
#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceParts ()) {
    gLogStream <<
      "Finalizing part " <<
      getPartCombinedName () <<
      ", line " << inputLineNumber <<
      std::endl;
  }
#endif

  ++gIndenter;

  if (! getPartStaveNumbersToStavesMap.size ()) {
    std::stringstream s;

    s <<
      "Part " <<
      getPartCombinedName () <<
      " appears in the part list, but doesn't contain any stave";

    musicxmlWarning (
      gGlobalServiceRunData->getInputSourceName (),
      inputLineNumber,
      s.str ());
  }

  else {
    // sort the staves to have harmonies above and figured bass below the part
    fPartAllStavesList.sort (
      compareStavesToHaveFiguredBassesBelowCorrespondingPart);

    // finalize the staves
    for (
      std::map<int, S_msrStaff>::const_iterator i =
      getPartStaveNumbersToStavesMap.begin ();
      i != getPartStaveNumbersToStavesMap.end ();
      ++i
    ) {
      S_msrStaff staff = (*i).second;

      staff->
        finalizeStaff (
          inputLineNumber);
    } // for
  }

  // set score instrument names max lengthes if relevant
  setPartInstrumentNamesMaxLengthes ();

  // collect the part measures slices from the staves
  collectPartMeasuresSlices (
    inputLineNumber);

  --gIndenter;
}
\end{lstlisting}



% -------------------------------------------------------------------------
\section{Finalizing staves}
% -------------------------------------------------------------------------

\Method{msrStaff}{finalizeStaff} \cascade\ s to \method{msrVoice}{finalizeVoice} and collects the staff measures slices:
\begin{lstlisting}[language=CPlusPlus]
void msrStaff::finalizeStaff (int inputLineNumber)
{
#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceStaves ()) {
    gLogStream <<
      "Finalizing staff \"" <<
      getStaffName () << "\"" <<
      ", line " << inputLineNumber <<
      std::endl;
  }
#endif

  ++gIndenter;

  // finalize the voices
#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceVoices ()) {
    gLogStream <<
      "Finalizing the voices in staff \"" <<
      getStaffName () << "\"" <<
      ", line " << inputLineNumber <<
      std::endl;
  }
#endif

  for (
    std::map<int, S_msrVoice>::const_iterator i =
      fStaffVoiceNumbersToAllVoicesMap.begin ();
    i != fStaffVoiceNumbersToAllVoicesMap.end ();
    ++i
  ) {
    S_msrVoice
      voice = (*i).second;

    voice->
      finalizeVoice (
        inputLineNumber);
  } // for

  // collect the staff measures slices from the voices
  collectStaffMeasuresSlices (
    inputLineNumber);

  --gIndenter;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Finalizing voices}
% -------------------------------------------------------------------------

\Method{msrVoice}{finalizeVoice} handles pending repeats if any and collects the voice measures into a flat list. It does not, however, \cascade\ to finalizing the voice repeats and measures.
\begin{lstlisting}[language=CPlusPlus]
void msrVoice::finalizeVoice (
  int inputLineNumber)
{
	// ... ... ...

  if (fVoiceHasBeenFinalized) {
    std::stringstream s;

    s <<
      "Attempting to finalize  voice \"" <<
      asShortString () <<
      "\" more than once";

    msrInternalError (
      gGlobalServiceRunData->getInputSourceName (),
      fInputLineNumber,
      __FILE__, __LINE__,
      s.str ());
  }

  // set part shortest note duration if relevant
  S_msrPart
    voicePart =
      fetchVoiceUpLinkToPart ();

  Rational
    partShortestNoteDuration =
      voicePart->
        getPartShortestNoteDuration ();

	// ... ... ...

  if (fVoiceShortestNoteDuration < partShortestNoteDuration) {
    // set the voice part shortest note duration
    voicePart->
      setPartShortestNoteDuration (
        fVoiceShortestNoteDuration);

    // set the voice part shortest note tuplet factor // JMI
    voicePart->
      setPartShortestNoteTupletFactor (
        fVoiceShortestNoteTupletFactor);
  }

  // is this voice totally empty? this should be rare...
  if (
    fVoiceInitialElementsList.size () == 0
      &&
    fVoiceLastSegment->getSegmentElementsList ().size () == 0
  ) {
    std::stringstream s;

    s <<
      "Voice \"" <<
      getVoiceName () <<
      "\" is totally empty, no contents ever specified for it" <<
      std::endl;

    musicxmlWarning (
      gGlobalServiceRunData->getInputSourceName (),
      inputLineNumber,
      s.str ());
  }

  // are there pending repeats in the voice repeats stack???
  unsigned int voicePendingRepeatDescrsStackSize =
    fVoicePendingRepeatDescrsStack.size ();

	// ... ... ...

  // collect the voice measures into the flat list
  collectVoiceMeasuresIntoFlatList (
    inputLineNumber);

  fVoiceHasBeenFinalized = true;

	// ... ... ...
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Finalizing repeats}
% -------------------------------------------------------------------------


% -------------------------------------------------------------------------
\section{Finalizing measures}
% -------------------------------------------------------------------------

\Method{msrMeasure}{finalizeMeasure} is not \cascaded. It delegates finalization to voice kind specific methods presented in the subsections below, handles pending repeats if any, and assigns positions in the measure to the measure's elements:
\begin{lstlisting}[language=CPlusPlus]
void msrMeasure::finalizeMeasure (
  int                          inputLineNumber,
  msrMeasureRepeatContextKind measureRepeatContextKind,
  std::string        context)
{
  if (fMeasureHasBeenFinalized) {
    std::stringstream s;

    s <<
      "Attempting to finalize measure " <<
      this->asShortString () <<
      " more than once in segment '" <<
      fMeasureUpLinkToSegment->getSegmentAbsoluteNumber () <<
      "', context: " << context <<
      "', measureFinalizationContext: " << fMeasureFinalizationContext <<
      " in voice \"" <<
      fMeasureUpLinkToSegment->
        getSegmentUpLinkToVoice ()->
          getVoiceName () <<
      "\" (" << context << ")" <<
      ", line " << inputLineNumber;

		// ... ... ...

    msrInternalWarning (
      gGlobalServiceRunData->getInputSourceName (),
      fInputLineNumber,
      s.str ());
  }

  else {
    S_msrVoice
      voice =
        fMeasureUpLinkToSegment->
          getSegmentUpLinkToVoice ();

		// ... ... ...

    // delegate to voice kind specific methods
    switch (voice->getVoiceKind ()) {
      case msrVoiceKind::kVoiceKindRegular:
        finalizeRegularMeasure (
          inputLineNumber,
          measureRepeatContextKind,
          context);
        break;

      case msrVoiceKind::kVoiceKindDynamics:
        break;

      case msrVoiceKind::kVoiceKindHarmonies:
        finalizeHarmonyMeasure (
          inputLineNumber,
          measureRepeatContextKind,
          context);
        break;
      case msrVoiceKind::kVoiceKindFiguredBass:
        finalizeFiguredBassMeasure (
          inputLineNumber,
          measureRepeatContextKind,
          context);
        break;
    } // switch

    // position in voice
    Rational
      voicePosition =
        fetchMeasureUpLinkToVoice ()->
          getCurrentVoicePosition ();

    // assign measure' elements measure position
    for (
      std::list<S_msrMeasureElement>::const_iterator i = fMeasureElementsList.begin ();
      i != fMeasureElementsList.end ();
      ++i
    ) {
      S_msrMeasureElement measureElement = (*i);

      measureElement->
        setMeasureElementVoicePosition (
          voicePosition,
          "finalizeMeasure()");
    } // for

    // register finalization
    fMeasureHasBeenFinalized = true;
    fMeasureFinalizationContext = context;
  }
}
\end{lstlisting}


% -------------------------------------------------------------------------
\subsection{Finalizing regular measures}
% -------------------------------------------------------------------------

\begin{lstlisting}[language=CPlusPlus]
void msrMeasure::finalizeRegularMeasure (
  int                          inputLineNumber,
  msrMeasureRepeatContextKind measureRepeatContextKind,
  std::string        context)
{
  // fetch the regular voice
  S_msrVoice
    voice =
      fMeasureUpLinkToSegment->
        getSegmentUpLinkToVoice ();

  // fetch the regular voice's part
  S_msrPart
    regularPart =
      voice->
        fetchVoiceUpLinkToPart ();

  mfAssert (
    __FILE__, __LINE__,
    regularPart != nullptr,
    "regularPart is null");

  if (false) { // JMI
    gLogStream <<
      "---> regularPart: " <<
      std::endl;

    ++gIndenter;
    gLogStream <<
      regularPart <<
      std::endl;
    --gIndenter;
    gLogStream << std::endl;
  }

  Rational
    measureWholeNotesDurationFromPartMeasuresVector =
      regularPart->
        getPartMeasuresWholeNotesDurationsVector () [
           fMeasureOrdinalNumberInVoice - 1 ];

#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceMeasures ()) {
    gLogStream <<
      "Finalizing regular measure " <<
      this->asShortString () <<
      " in segment '" <<
      fMeasureUpLinkToSegment->getSegmentAbsoluteNumber () <<
      "' in regular voice \"" <<
      voice->getVoiceName () <<
      "\" (" << context << ")" <<
      ", measureWholeNotesDurationFromPartMeasuresVector: " <<
      measureWholeNotesDurationFromPartMeasuresVector <<
      ", line " << inputLineNumber <<
      std::endl;
  }
#endif

  ++gIndenter;

#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceMeasuresDetails ()) {
    displayMeasure (
      inputLineNumber,
      "finalizeRegularMeasure() 1");
  }
#endif

  padUpToPositionAtTheEndOfTheMeasure (
    inputLineNumber,
    measureWholeNotesDurationFromPartMeasuresVector);

  // register this measures's length in the part
  S_msrPart
    part =
      this->fetchMeasureUpLinkToPart ();

  part->
    registerOrdinalMeasureNumberWholeNotesDuration (
      inputLineNumber,
      fMeasureOrdinalNumberInVoice,
      fCurrentMeasureWholeNotesDuration);

  // determine the measure kind and purist number
  determineMeasureKindAndPuristNumber (
    inputLineNumber,
    measureRepeatContextKind);

  // pad measure up to whole measure whole notes high tide JMI ???
  switch (fMeasureKind) {
    case msrMeasureKind::kMeasureKindCadenza:
      break;

    case msrMeasureKind::kMeasureKindOvercomplete:
    case msrMeasureKind::kMeasureKindAnacrusis:
    case msrMeasureKind::kMeasureKindRegular:
    case msrMeasureKind::kMeasureKindIncompleteStandalone: // JMI
    case msrMeasureKind::kMeasureKindIncompleteLastInRepeatCommonPart: // JMI
    case msrMeasureKind::kMeasureKindIncompleteLastInRepeatHookedEnding: // JMI
    case msrMeasureKind::kMeasureKindIncompleteLastInRepeatHooklessEnding: // JMI
    case msrMeasureKind::kMeasureKindIncompleteNextMeasureAfterCommonPart: // JMI
    case msrMeasureKind::kMeasureKindIncompleteNextMeasureAfterHookedEnding: // JMI
    case msrMeasureKind::kMeasureKindIncompleteNextMeasureAfterHooklessEnding: // JMI
      break;

    case msrMeasureKind::kMeasureKindUnknown:
      // JMI ???
      break;

    case msrMeasureKind::kMeasureKindMusicallyEmpty:
      {
      /* JMI
          */
      }
      break;
  } // switch

  // is there a single note or rest occupying the full measure?
  if (fMeasureLongestNote) {
    if (
      fMeasureLongestNote-> getMeasureElementSoundingWholeNotes ()
        ==
      fFullMeasureWholeNotesDuration
    ) {
#ifdef OAH_TRACING_IS_ENABLED
      if (gGlobalTracingOahGroup->getTraceMeasures ()) {
        gLogStream <<
          "Note '" <<
          fMeasureLongestNote->asShortString () <<
          "' occupies measure " <<
          this->asShortString () <<
          " fully in segment '" <<
          fMeasureUpLinkToSegment->getSegmentAbsoluteNumber () <<
          "' in voice \"" <<
          voice->getVoiceName () <<
          "\", line " << inputLineNumber <<
          std::endl;
      }
#endif

      fMeasureLongestNote->
        setNoteOccupiesAFullMeasure ();
    }
  }

#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceMeasuresDetails ()) {
    displayMeasure (
      inputLineNumber,
      "finalizeRegularMeasure() 2");
  }
#endif

  --gIndenter;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\subsection{Finalizing harmonies measures}
% -------------------------------------------------------------------------

\begin{lstlisting}[language=CPlusPlus]
void msrMeasure::finalizeHarmonyMeasure (
  int                          inputLineNumber,
  msrMeasureRepeatContextKind measureRepeatContextKind,
  std::string        context)
{
  // fetch the harmonies voice
  S_msrVoice
    harmoniesVoice =
      fMeasureUpLinkToSegment->
        getSegmentUpLinkToVoice ();

  // fetch the harmonies part
  S_msrPart
    harmoniesPart =
      harmoniesVoice->
        fetchVoiceUpLinkToPart ();

  mfAssert (
    __FILE__, __LINE__,
    harmoniesPart != nullptr,
    "harmoniesPart is null");

#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceHarmonies ()) {
    gLogStream <<
      "Finalizing harmonies measure " <<
      this->asShortString () <<
      " in segment '" <<
      fMeasureUpLinkToSegment->getSegmentAbsoluteNumber () <<
      "' in harmonies voice \"" <<
      harmoniesVoice->getVoiceName () <<
      "\" (" << context << ")" <<
      ", line " << inputLineNumber <<
      std::endl;
  }
#endif

  ++gIndenter;

#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceHarmoniesDetails ()) {
    displayMeasure (
      inputLineNumber,
      "finalizeHarmonyMeasure() 1");
  }
#endif

#ifdef OAH_TRACING_IS_ENABLED
  // get the harmoniesPart number of measures
  int
    harmoniesPartNumberOfMeasures =
      harmoniesPart->
        getPartNumberOfMeasures ();

  if (gGlobalTracingOahGroup->getTraceHarmonies ()) {
    gLogStream <<
      "fMeasureOrdinalNumberInVoice = " <<
      fMeasureOrdinalNumberInVoice <<
      ", harmoniesPartNumberOfMeasures = " <<
      harmoniesPartNumberOfMeasures <<
      std::endl;
  }
#endif

  // the measureWholeNotesDuration has to be computed
  Rational
    measureWholeNotesDurationFromPartMeasuresVector =
      harmoniesPart->
        getPartMeasuresWholeNotesDurationsVector () [
           fMeasureOrdinalNumberInVoice - 1 ];

  // handle the harmonies in this measure
  finalizeTheHarmoniesInHarmoniesMeasure (
    inputLineNumber,
    context);

  // pad the measure up to measureWholeNotesDurationFromPartMeasuresVector
  padUpToPositionAtTheEndOfTheMeasure (
    inputLineNumber,
    measureWholeNotesDurationFromPartMeasuresVector);

  // determine the measure kind and purist number
  determineMeasureKindAndPuristNumber (
    inputLineNumber,
    measureRepeatContextKind);

#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceHarmoniesDetails ()) {
    displayMeasure (
      inputLineNumber,
      "finalizeHarmonyMeasure() 2");
  }
#endif

  --gIndenter;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\subsection{Finalizing figured bass measures}
% -------------------------------------------------------------------------

\begin{lstlisting}[language=CPlusPlus]
void msrMeasure::finalizeFiguredBassMeasure (
  int                          inputLineNumber,
  msrMeasureRepeatContextKind measureRepeatContextKind,
  std::string        context)
{
  // fetch the figured bass voice
  S_msrVoice
    figuredBassVoice =
      fMeasureUpLinkToSegment->
        getSegmentUpLinkToVoice ();

  // fetch the figured bass part
  S_msrPart
    figuredBassPart =
      figuredBassVoice->
        fetchVoiceUpLinkToPart ();

  mfAssert (
    __FILE__, __LINE__,
    figuredBassPart != nullptr,
    "figuredBassPart is null");

#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceFiguredBasses ()) {
    gLogStream <<
      "Finalizing figured bass measure " <<
      this->asShortString () <<
      " in segment '" <<
      fMeasureUpLinkToSegment->getSegmentAbsoluteNumber () <<
      "' in figured bass voice \"" <<
      figuredBassVoice->getVoiceName () <<
      "\" (" << context << ")" <<
      ", line " << inputLineNumber <<
      std::endl;
  }
#endif

  ++gIndenter;

#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceFiguredBassesDetails ()) {
    displayMeasure (
      inputLineNumber,
      "finalizeFiguredBassMeasure() 1");
  }
#endif

#ifdef OAH_TRACING_IS_ENABLED
  // get the figuredBassPart number of measures
  int
    figuredBassPartNumberOfMeasures =
      figuredBassPart->
        getPartNumberOfMeasures ();

  if (gGlobalTracingOahGroup->getTraceHarmonies ()) {
    gLogStream <<
      "fMeasureOrdinalNumberInVoice = " <<
      fMeasureOrdinalNumberInVoice <<
      ", figuredBassPartNumberOfMeasures = " <<
      figuredBassPartNumberOfMeasures <<
      std::endl;
  }
#endif

  // the measureWholeNotesDuration has to be computed
  Rational
    measureWholeNotesDuration =
      figuredBassPart->
        getPartMeasuresWholeNotesDurationsVector () [
           fMeasureOrdinalNumberInVoice - 1 ];

  // handle the figured bass elements in this measure
  finalizeFiguredBassesInFiguredBassMeasure (
    inputLineNumber,
    context);

  // pad the measure up to fFullMeasureWholeNotesDuration
  padUpToPositionAtTheEndOfTheMeasure (
    inputLineNumber,
    measureWholeNotesDuration);

  // determine the measure kind and purist number
  determineMeasureKindAndPuristNumber (
    inputLineNumber,
    measureRepeatContextKind);

#ifdef OAH_TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceFiguredBassesDetails ()) {
    displayMeasure (
      inputLineNumber,
      "finalizeFiguredBassMeasure() 2");
  }
#endif

  --gIndenter;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Determining measure positionss}
% -------------------------------------------------------------------------

