% !TEX root = MusicFormatsMaintainanceGuide.tex

% -------------------------------------------------------------------------
\chapter{Harmonies handling}\label{Harmonies handling}
% -------------------------------------------------------------------------

Harmonies are presented at \sectionRef{Harmonies}.

The useful options here are:
\begin{itemize}
\item \optionBoth{trace-harmonies}{tharms}
\item \optionBoth{display-msr-skeleton}{dmsrskel}
\item \optionBoth{display-msr-1}{dmsr1}
\item \optionBoth{display-msr-1-short}{dmsr1s} and \optionBoth{display-msr-1-details}{dmsr1d}
\item \optionBoth{display-msr-2msr2}{dmsr2}
\item \optionBoth{display-msr-2-short}{msr2s} and \optionBoth{display-msr-2-details}{dmsr2d}
\end{itemize}

Harmonies need special treatment since we need to determine their position in a harmony  voice. This is different than \mxml, where they are simply \drawn\ at the current music position, so to say.

They are handled this way:
\begin{itemize}
\item harmonies are stored in \class{msrNote}:
\item they are also stored in \class{msrPart}, \class{msrChord} and \class{msrTuplet} (\denorm);
\end{itemize}

In \class{msrNote}, there is:
\begin{lstlisting}[language=CPlusPlus]
    // harmonies
    void                  appendHarmonyToNoteHarmoniesList (
                            const S_msrHarmony& harmony);

    const std::list<S_msrHarmony>&
                          getNoteHarmoniesList () const
                              { return fNoteHarmoniesList; }

		// ... ... ...

    // harmonies
    // ------------------------------------------------------

    std::list<S_msrHarmony>
                          fNoteHarmoniesList;

		// ... ... ...
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Harmonies staves and voices}
% -------------------------------------------------------------------------

Every \class{msrVoice} instance in \mf\ belongs to an \class{msrStaff} instance. Staves are created specifically to hold harmonies voices, using specific numbers defined in \msr{msrParts.h}:
\begin{lstlisting}[language=CPlusPlus]
  public:

    // constants
    // ------------------------------------------------------

    #define msrPart::K_PART_HARMONIES_STAFF_NUMBER       10
    #define msrPart::K_PART_HARMONIES_VOICE_NUMBER       11
\end{lstlisting}

In \class{msrStaff}, there is:
\begin{lstlisting}[language=CPlusPlus]
    void                  registerHarmoniesVoiceByItsNumber (
                            int        inputLineNumber,
                            const S_msrVoice& voice);
\end{lstlisting}

\Class{msrPart} also contains:
\begin{lstlisting}[language=CPlusPlus]
   // harmonies

    S_msrVoice            createPartHarmoniesVoice (
                            int    inputLineNumber,
                            std::string currentMeasureNumber);

    void                  appendHarmonyToPart (
                            const S_msrVoice&  harmonySupplierVoice,
                            const S_msrHarmony& harmony);

    void                  appendHarmonyToPartClone (
                            const S_msrVoice&   harmonySupplierVoice,
                            const S_msrHarmony& harmony);
\end{lstlisting}

\begin{lstlisting}[language=CPlusPlus]
    // harmonies

    S_msrStaff            fPartHarmoniesStaff;
    S_msrVoice            fPartHarmoniesVoice;
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Harmonies staves creation}
% -------------------------------------------------------------------------

This is done in \mxsrToMsrBoth{mxsr2msrSkeletonBuilder.cpp}:
\begin{lstlisting}[language=CPlusPlus]
S_msrVoice mxsr2msrSkeletonBuilder::createPartHarmoniesVoiceIfNotYetDone (
  int        inputLineNumber,
  const S_msrPart&  part)
{
  // is the harmonies voice already present in part?
  S_msrVoice
    partHarmoniesVoice =
      part->
        getPartHarmoniesVoice ();

  if (! partHarmoniesVoice) {
    // create the harmonies voice and append it to the part
    partHarmoniesVoice =
      part->
        createPartHarmoniesVoice (
          inputLineNumber,
          fCurrentMeasureNumber);
  }

  return partHarmoniesVoice;
}
\end{lstlisting}

Method {msrPart}{createPartHarmoniesVoice} creates the part harmonies staff and the part harmonies voice, and then registers the latter in the former:
\begin{lstlisting}[language=CPlusPlus]
S_msrVoice msrPart::createPartHarmoniesVoice (
  int    inputLineNumber,
  std::string currentMeasureNumber)
{
	// ... ... ...

  // create the part harmonies staff
  int partHarmoniesStaffNumber =
    msrPart::K_PART_HARMONIES_STAFF_NUMBER;

	// ... ... ...

  fPartHarmoniesStaff =
    addHarmoniesStaffToPart (
      inputLineNumber);

	// ... ... ...

  // create the part harmonies voice
  int partHarmoniesVoiceNumber =
    msrPart::K_PART_HARMONIES_VOICE_NUMBER;

	// ... ... ...

  fPartHarmoniesVoice =
    msrVoice::create (
      inputLineNumber,
      msrVoiceKind::kVoiceKindHarmonies,
      partHarmoniesVoiceNumber,
      msrVoiceCreateInitialLastSegmentKind::kCreateInitialLastSegmentYes,
      fPartHarmoniesStaff);

  // register the part harmonies voice in part harmonies staff
  fPartHarmoniesStaff->
    registerVoiceInStaff (
      inputLineNumber,
      fPartHarmoniesVoice);

	// ... ... ...

  return fPartHarmoniesVoice;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Translating harmonies from MXSR to MSR}
% -------------------------------------------------------------------------

This is done in \mxsrToMsr{}.

The MSR score skeleton created in \mxsrToMsrBoth{mxsr2msrSkeletonBuilder} contains the part groups, parts, staves and voices, as well as the number of measures. The voices do not contain any music elements yet.

A harmoniy belongs to a \musicXmlMarkup{part} in \mxml, but we sometimes need to have it attached to a note. When visiting an \smartPointerType{S_harmony} element, \field{mxsr2msrSkeletonBuilder}{fThereAreHarmoniesToBeAttachedToCurrentNote} it used to account for that:%%%JMI
\begin{lstlisting}[language=CPlusPlus]
void mxsr2msrSkeletonBuilder::visitStart ( S_harmony& elt )
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalMxsrOahGroup->getTraceMxsrVisitors ()) {
    gLogStream <<
      "--> Start visiting S_harmony" <<
      ", harmoniesVoicesCounter = " << fHarmoniesVoicesCounter <<
      ", line " << elt->getInputLineNumber () <<
      std::endl;
  }
#endif

  /* JMI ???
    several harmonies can be attached to a given note,
    leading to as many harmonies voices in the current part
  */

  // take harmonies voice into account
  ++fHarmoniesVoicesCounter; // UNUSED JMI

  fThereAreHarmoniesToBeAttachedToCurrentNote = true;
}
\end{lstlisting}

Upon the second visit of \class{msrNote}, the part harmonies voice is created if harmonies are not to be ignored due to option \optionBoth{ignore-musicxml-harmonies}{oharms} and it has not been created yet:
\begin{lstlisting}[language=CPlusPlus]
void mxsr2msrSkeletonBuilder::visitEnd ( S_note& elt )
{
	// ... ... ...

  // are there harmonies attached to the current note?
  if (fThereAreHarmoniesToBeAttachedToCurrentNote) {
    if (gGlobalMxsr2msrOahGroup->getIgnoreHarmonies ()) {
#ifdef TRACING_IS_ENABLED
      if (gGlobalTracingOahGroup->getTraceHarmonies ()) {
        gLogStream <<
          "Ignoring the harmonies" <<
          ", line " <<
          inputLineNumber <<
          std::endl;
      }
#endif
    }
    else {
      // create the part harmonies voice if not yet done
      S_msrVoice
        partHarmoniesVoice =
          createPartHarmoniesVoiceIfNotYetDone (
            inputLineNumber,
            fCurrentPart);
    }

    fThereAreHarmoniesToBeAttachedToCurrentNote = false;
  }

	// ... ... ...
}
\end{lstlisting}

Creating the part harmonies voice is delegated to the part:
\begin{lstlisting}[language=CPlusPlus]
S_msrVoice mxsr2msrSkeletonBuilder::createPartHarmoniesVoiceIfNotYetDone (
  int        inputLineNumber,
  const S_msrPart&  part)
{
  // is the harmonies voice already present in part?
  S_msrVoice
    partHarmoniesVoice =
      part->
        getPartHarmoniesVoice ();

  if (! partHarmoniesVoice) {
    // create the harmonies voice and append it to the part
    partHarmoniesVoice =
      part->
        createPartHarmoniesVoice (
          inputLineNumber,
          fCurrentMeasureNumber);
  }

  return partHarmoniesVoice;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Translating harmonies from MXSR to MSR}%%%JMI
% -------------------------------------------------------------------------

This is done in \mxsrToMsr{}.

This is where the \class{msrHarmony} instances are created.


% -------------------------------------------------------------------------
\subsection{First {\tt S_harmony} visit}\smartPointerTypeIndex{S_harmony}
% -------------------------------------------------------------------------

The first visit of \smartPointerType{S_harmony} initializes the fields storing values to be gathered visiting subelements:
\begin{lstlisting}[language=CPlusPlus]
void mxsr2msrTranslator::visitStart ( S_harmony& elt )
{
  int inputLineNumber =
    elt->getInputLineNumber ();

#ifdef TRACING_IS_ENABLED
  if (gGlobalMxsrOahGroup->getTraceMxsrVisitors ()) {
    gLogStream <<
      "--> Start visiting S_harmony" <<
      ", line " << inputLineNumber <<
      std::endl;
  }
#endif

  ++fHarmoniesVoicesCounter;

  fCurrentHarmonyInputLineNumber       = inputLineNumber;

  fCurrentHarmonyRootDiatonicPitchKind = msrDiatonicPitchKind::kDiatonicPitch_NO_;
  fCurrentHarmonyRootAlterationKind    = msrAlterationKind::kAlterationNatural;
  fCurrentHarmonyKind                  = msrHarmonyKind::kHarmony_NO_;
  fCurrentHarmonyKindText              = "";
  fCurrentHarmonyInversion             = K_HARMONY_NO_INVERSION;
  fCurrentHarmonyBassDiatonicPitchKind = msrDiatonicPitchKind::kDiatonicPitch_NO_;
  fCurrentHarmonyBassAlterationKind    = msrAlterationKind::kAlterationNatural;
  fCurrentHarmonyDegreeValue           = -1;
  fCurrentHarmonyDegreeAlterationKind  = msrAlterationKind::kAlterationNatural;

  fCurrentHarmonyWholeNotesOffset = rational (0, 1);

  fOnGoingHarmony = true;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\subsection{Second {\tt S_harmony} visit}\smartPointerTypeIndex{S_harmony}
% -------------------------------------------------------------------------

Upon the second visit of \smartPointerType{S_harmony}, a \class{msrHarmony} instance is created, populated and appended to \fieldName{mxsr2msrTranslator}{fPendingHarmoniesList}.\\
The voice uplink will be set later, hence the use of \method{msrHarmony}{create}:
\begin{lstlisting}[language=CPlusPlus]
void mxsr2msrTranslator::visitEnd ( S_harmony& elt )
{
	// ... ... ...

  if (gGlobalMxsr2msrOahGroup->getIgnoreHarmonies ()) {
 #ifdef TRACING_IS_ENABLED
    if (gGlobalTracingOahGroup->getTraceHarmonies ()) {
      gLogStream <<
        "Ignoring harmony" <<
        ", line " <<
        inputLineNumber <<
        std::endl;
    }
#endif
  }
  else {
   // create the harmony
#ifdef TRACING_IS_ENABLED
    if (gGlobalTracingOahGroup->getTraceHarmoniesDetails ()) {
      gLogStream <<
        "Creating a harmony" <<
        ", line " << inputLineNumber << ":" <<
        std::endl;

    	// ... ... ...
    }
#endif

    S_msrHarmony
      harmony =
        msrHarmony::create (
          fCurrentHarmonyInputLineNumber,
          // no harmoniesUpLinkToVoice yet

          fCurrentHarmonyRootQuarterTonesPitchKind,

          fCurrentHarmonyKind,
          fCurrentHarmonyKindText,

          fCurrentHarmonyInversion,

          fCurrentHarmonyBassQuarterTonesPitchKind,

          rational (1, 1),            // harmonySoundingWholeNotes,
                                      // will be set upon next note handling
          rational (1, 1),            // harmonyDisplayWholeNotes,
                                      // will be set upon next note handling
          fCurrentHarmoniesStaffNumber,
          msrTupletFactor (1, 1),     // will be set upon next note handling
          fCurrentHarmonyWholeNotesOffset);

    // append pending harmony degrees if any to the harmony
    if (! fCurrentHarmonyDegreesList.size ()) {
#ifdef TRACING_IS_ENABLED
      if (gGlobalTracingOahGroup->getTraceHarmoniesDetails ()) {
        musicxmlWarning (
          gGlobalServiceRunData->getInputSourceName (),
          inputLineNumber,
          "harmony has no degrees contents");
      }
#endif
    }

    else {
    	// handle harmony degrees if any
      while (fCurrentHarmonyDegreesList.size ()) {
        S_msrHarmonyDegree
          harmonyDegree =
            fCurrentHarmonyDegreesList.front ();

				// ... ... ...

        // append it to harmony's degrees std::list
        harmony->
          appendHarmonyDegreeToHarmony (
            harmonyDegree);

        // remove it from the std::list
        fCurrentHarmonyDegreesList.pop_front ();
      } // while
    }

    // attach the current frame if any to the harmony
    if (fCurrentFrame) {
      harmony->setHarmonyFrame (fCurrentFrame);
    }

    // append the harmony to the pending harmonies std::list
    fPendingHarmoniesList.push_back (harmony);
  }

  fOnGoingHarmony = false;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\subsection{Attaching {\tt msrHarmony} instances to notes}\className{msrHarmony}
% -------------------------------------------------------------------------

The contents of \fieldName{mxsr2msrTranslator}{fPendingHarmoniesList} is attached to the \class{msrNote} instance in\\
\method{mxsr2msrTranslator}{populateNote}:
\begin{lstlisting}[language=CPlusPlus]
void mxsr2msrTranslator::populateNote (
  int       inputLineNumber,
  const S_msrNote& newNote)
{
	// ... ... ...

  // handle the pending harmonies if any
  if (fPendingHarmoniesList.size ()) {
    // get voice to insert harmonies into
    S_msrVoice
      voiceToInsertHarmoniesInto =
        fCurrentPart->
          getPartHarmoniesVoice ();

		// ... ... ...

    handlePendingHarmonies (
      newNote,
      voiceToInsertHarmoniesInto);

    // reset harmony counter
    fHarmoniesVoicesCounter = 0;
  }
}
\end{lstlisting}


% -------------------------------------------------------------------------
\subsection{Populating {\tt msrHarmony} instances}\className{msrHarmony}
% -------------------------------------------------------------------------

The \class{msrHarmony} instances are populated further in \msr{mxsr2msrTranslator.cpp} and attached to the note by \method{msrNote}{appendHarmonyToNoteHarmoniesList}: %%%JMI
\begin{lstlisting}[language=CPlusPlus]
void mxsr2msrTranslator::handlePendingHarmonies (
  S_msrNote  newNote,
  const S_msrVoice& voiceToInsertInto)
{
	// ... ... ...

  rational
    newNoteSoundingWholeNotes =
      newNote->
        getMeasureElementSoundingWholeNotes (),
    newNoteDisplayWholeNotes =
      newNote->
        getNoteDisplayWholeNotes ();

  while (fPendingHarmoniesList.size ()) { // recompute at each iteration
    S_msrHarmony
      harmony =
        fPendingHarmoniesList.front ();

    /*
       MusicXML harmonies don't have a duration,
       and MSR could follow this line, but LilyPond needs one...
       So:
         - we register all harmonies with the duration of the next note
         - they will be sorted by position in the measure in finalizeMeasure(),
           at which time their duration may be shortened
           so that the offsets values are enforced
           and they don't overflow the measure
      It is VITAL that harmonies measures be finalized
      AFTER the corresponding measure in the regular voice,
      since the current sounding whole notes of the latter is needed for that
    */

    // set the harmony's sounding whole notes
    harmony->
      setMeasureElementSoundingWholeNotes (
        newNoteSoundingWholeNotes,
        "mxsr2msrTranslator::handlePendingHarmonies()");

    // set the harmony's display whole notes JMI useless???
    harmony->
      setHarmonyDisplayWholeNotes (
        newNoteDisplayWholeNotes);

    // set the harmony's tuplet factor
    harmony->
      setHarmonyTupletFactor (
        msrTupletFactor (
          fCurrentNoteActualNotes,
          fCurrentNoteNormalNotes));

    // attach the harmony to newNote
    newNote->
      appendHarmonyToNoteHarmoniesList (
        harmony);

    // get the part harmonies voice
    S_msrVoice
      partHarmoniesVoice =
        fCurrentPart->
          getPartHarmoniesVoice ();

    // sanity check
    mfAssert (
      __FILE__, __LINE__,
      partHarmoniesVoice != nullptr,
      "partHarmoniesVoice is null");

    // set the harmony's voice upLink
    // only now that we know which harmonies voice will contain it
    harmony->
      setHarmoniesUpLinkToVoice (
        partHarmoniesVoice);

/* JMI CAFE
    // append the harmony to the part harmonies voice
    partHarmoniesVoice->
      appendHarmonyToVoice (
        harmony);
*/
    // don't append the harmony to the part harmonies voice // BLARK
    // before the note itself has been appended to the voice

    // remove the harmony from the std::list
    fPendingHarmoniesList.pop_front ();
  } // while
}
\end{lstlisting}


% -------------------------------------------------------------------------
\subsection{First {\tt S_harmony} visit}\className{msrHarmony}
% -------------------------------------------------------------------------

\Method{msrNote}{appendHarmonyToNoteHarmoniesList} is where the harmony's note uplink is set:
\begin{lstlisting}[language=CPlusPlus]
void msrNote::appendHarmonyToNoteHarmoniesList (const S_msrHarmony& harmony)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalTracingOahGroup->getTraceHarmonies ()) {
    gLogStream <<
      "Appending harmony " <<
      harmony->asString () <<
      " to the harmonies std::list of " <<
      asString () <<
      ", line " << fInputLineNumber <<
      std::endl;
  }
#endif

  // update the harmony whole notes if it belongs to a tuplet ??? utf8.xml JMI

  fNoteHarmoniesList.push_back (harmony);

  // register this note as the harmony note upLink
  harmony->
    setHarmonyUpLinkToNote (this);
}
\end{lstlisting}

When a harmony is attached to a note that is a chord member, we have to attach it to the chord too, to facilitate setting its \pim\ when setting the chord's one.
\begin{lstlisting}[language=CPlusPlus]
void mxsr2msrTranslator::copyNoteHarmoniesToChord (
  const S_msrNote&  note,
  const S_msrChord& chord)
{
  // copy note's harmony if any from the first note to chord

  const std::list<S_msrHarmony>&
    noteHarmoniesList =
      note->getNoteHarmoniesList ();

  if (noteHarmoniesList.size ()) {
    std::list<S_msrHarmony>::const_iterator i;
    for (i=noteHarmoniesList.begin (); i!=noteHarmoniesList.end (); ++i) {
      S_msrHarmony harmony = (*i);

#ifdef TRACING_IS_ENABLED
      if (gGlobalTracingOahGroup->getTraceHarmonies ()) {
        gLogStream <<
          "Copying harmony '" <<
          harmony->asString () <<
          "' from note " << note->asString () <<
          " to chord '" << chord->asString () <<
          "'" <<
          std::endl;
      }
#endif

      chord->
        appendHarmonyToChord (harmony);

    } // for
  }
}
\end{lstlisting}


% -------------------------------------------------------------------------
\subsection{Inserting {\tt msrHarmony} instances in the part harmonies voice}\className{msrHarmony}
% -------------------------------------------------------------------------

Inserting the harmonies in the part harmonies voice is done in \method{msrVoice}{appendNoteToVoice} in \msr{msrNotes.cpp}:
\begin{lstlisting}[language=CPlusPlus]
void msrVoice::appendNoteToVoice (const S_msrNote& note)
{
	// ... ... ...

  // are there harmonies attached to this note? // BLARK
  const std::list<S_msrHarmony>&
    noteHarmoniesList =
      note->
        getNoteHarmoniesList ();

  if (noteHarmoniesList.size ()) {
    // get the current part's harmonies voice
    S_msrVoice
      partHarmoniesVoice =
        part->
          getPartHarmoniesVoice ();

    for (S_msrHarmony harmony : noteHarmoniesList) {
      // append the harmony to the part harmonies voice
      partHarmoniesVoice->
        appendHarmonyToVoice (
          harmony);
    } // for
  }

	// ... ... ...
};
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Translating harmonies from MSR to MSR}
% -------------------------------------------------------------------------

This is done in \msrToMsr{}.

In \msrToMsr{msr2msrTranslator.cpp}, a newborn clone of the harmony is created upon the first visit, stored in \fieldName{msr2msrTranslator}{fCurrentHarmonyClone}, and appended to the current non grace note clone, the current chord clone or to the current voice clone, if the latter is a harmonies voice: %%%JMI
\begin{lstlisting}[language=CPlusPlus]
void msr2msrTranslator::visitStart (S_msrHarmony& elt)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "--> Start visiting msrHarmony '" <<
      elt->asString () <<
      ", fOnGoingNonGraceNote: " << fOnGoingNonGraceNote <<
      ", fOnGoingChord: " << fOnGoingChord <<
      ", fOnGoingHarmoniesVoice: " << fOnGoingHarmoniesVoice <<
      ", fOnGoingHarmony: " << fOnGoingHarmony <<
      "', line " << elt->getInputLineNumber () <<
      std::endl;
  }
#endif

  // create a harmony new born clone
  fCurrentHarmonyClone =
    elt->
      createHarmonyNewbornClone (
        fCurrentVoiceClone);

  if (fOnGoingNonGraceNote) {
    // register the harmony in the current non-grace note clone
    fCurrentNonGraceNoteClone->
      appendHarmonyToNoteHarmoniesList (
        fCurrentHarmonyClone);

    // don't append the harmony to the part harmony,
    // this has been done in pass2b // JMI ???
  }

  else if (fOnGoingChord) {
    // register the harmony in the current chord clone
    fCurrentChordClone->
      appendHarmonyToChord (fCurrentHarmonyClone); // JMI
  }

  else if (fOnGoingHarmoniesVoice) {
  /* JMI
    // get the harmony whole notes offset
    rational
      harmonyWholeNotesOffset =
        elt->getHarmonyWholeNotesOffset ();

    // is harmonyWholeNotesOffset not equal to 0?
    if (harmonyWholeNotesOffset.getNumerator () != 0) {
      // create skip with duration harmonyWholeNotesOffset
      S_msrNote
        skip =
          msrNote::createSkipNote (
            elt->                getInputLineNumber (),
            "666", // JMI elt->                getHarmoniesMeasureNumber (),
            elt->                getHarmonyDisplayWholeNotes (), // would be 0/1 otherwise JMI
            elt->                getHarmonyDisplayWholeNotes (),
            0, // JMI elt->                getHarmonyDotsNumber (),
            fCurrentVoiceClone-> getRegularVoiceStaffSequentialNumber (), // JMI
            fCurrentVoiceClone-> getVoiceNumber ());

      // append it to the current voice clone
      // to 'push' the harmony aside
      fCurrentVoiceClone->
        appendNoteToVoice (skip);
    }
*/

    // append the harmony to the current voice clone
    fCurrentVoiceClone->
      appendHarmonyToVoiceClone (
        fCurrentHarmonyClone);
  }

  else {
    std::stringstream s;

    s <<
      "harmony is out of context, cannot be handled: '" <<
      elt->asShortString () <<
      "'";

    msrInternalError (
      gGlobalServiceRunData->getInputSourceName (),
      elt->getInputLineNumber (),
      __FILE__, __LINE__,
      s.str ());
  }

  fOnGoingHarmony = true;
}
\end{lstlisting}

There are only fields updates upon the second visit:
\begin{lstlisting}[language=CPlusPlus]
void msr2msrTranslator::visitEnd (S_msrHarmony& elt)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "--> End visiting msrHarmony '" <<
      elt->asString () <<
      "'" <<
      ", line " << elt->getInputLineNumber () <<
      std::endl;
  }
#endif

  fCurrentHarmonyClone = nullptr;
  fOnGoingHarmony = false;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Translating harmonies from MSR to LPSR}
% -------------------------------------------------------------------------

This is done in \msrToLpsr{}.

The same occurs in \msrToLpsr{msr2lpsrTranslator.cpp}: a newborn clone of the harmony is created and appended to the current non grace note clone, the current chord clone or to the current voice clone, if the latter is a harmonies voice: %%%JMI
:
\begin{lstlisting}[language=CPlusPlus]
void msr2lpsrTranslator::visitStart (S_msrHarmony& elt)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "--> Start visiting msrHarmony '" <<
      elt->asString () <<
      ", onGoingNonGraceNote: " << fOnGoingNonGraceNote <<
      ", onGoingChord: " << fOnGoingChord <<
      ", onGoingHarmoniesVoice: " << fOnGoingHarmoniesVoice <<
      ", onGoingHarmony: " << fOnGoingHarmony <<
      "', line " << elt->getInputLineNumber () <<
      std::endl;
  }
#endif

  // create a harmony new born clone
  fCurrentHarmonyClone =
    elt->
      createHarmonyNewbornClone (
        fCurrentVoiceClone);

  if (fOnGoingNonGraceNote) {
    // register the harmony in the current non-grace note clone
    fCurrentNonGraceNoteClone->
      appendHarmonyToNoteHarmoniesList (
        fCurrentHarmonyClone);

    // don't append the harmony to the part harmony,
    // this has been done in pass2b // JMI ???
  }

  else if (fOnGoingChord) {
    // register the harmony in the current chord clone
    fCurrentChordClone->
      appendHarmonyToChord (fCurrentHarmonyClone); // JMI
  }

  else if (fOnGoingHarmoniesVoice) {
  /* JMI
    // get the harmony whole notes offset
    rational
      harmonyWholeNotesOffset =
        elt->getHarmonyWholeNotesOffset ();

    // is harmonyWholeNotesOffset not equal to 0?
    if (harmonyWholeNotesOffset.getNumerator () != 0) {
      // create skip with duration harmonyWholeNotesOffset
      S_msrNote
        skip =
          msrNote::createSkipNote (
            elt->                getInputLineNumber (),
            "666", // JMI elt->                getHarmoniesMeasureNumber (),
            elt->                getHarmonyDisplayWholeNotes (), // would be 0/1 otherwise JMI
            elt->                getHarmonyDisplayWholeNotes (),
            0, // JMI elt->                getHarmonyDotsNumber (),
            fCurrentVoiceClone-> getRegularVoiceStaffSequentialNumber (), // JMI
            fCurrentVoiceClone-> getVoiceNumber ());

      // append it to the current voice clone
      // to 'push' the harmony aside
      fCurrentVoiceClone->
        appendNoteToVoice (skip);
    }
*/

    // append the harmony to the current voice clone
    fCurrentVoiceClone->
      appendHarmonyToVoiceClone (
        fCurrentHarmonyClone);
  }

  else {
    std::stringstream s;

    s <<
      "harmony is out of context, cannot be handled: '" <<
      elt->asShortString () <<
      "'";

    msrInternalError (
      gGlobalServiceRunData->getInputSourceName (),
      elt->getInputLineNumber (),
      __FILE__, __LINE__,
      s.str ());
  }

  fOnGoingHarmony = true;
}
\end{lstlisting}

\pagebreak

Here too, there are only fields updates upon the second visit of \smartPointerType{S_msrHarmony} instances:
\begin{lstlisting}[language=CPlusPlus]
void msr2lpsrTranslator::visitEnd (S_msrHarmony& elt)
{
#ifdef TRACING_IS_ENABLED
  if (gGlobalMsrOahGroup->getTraceMsrVisitors ()) {
    gLogStream <<
      "--> End visiting msrHarmony '" <<
      elt->asString () <<
      "'" <<
      ", line " << elt->getInputLineNumber () <<
      std::endl;
  }
#endif

  fCurrentHarmonyClone = nullptr;
  fOnGoingHarmony = false;
}
\end{lstlisting}


% -------------------------------------------------------------------------
\section{Translating harmonies from LPSR to LilyPond}
% -------------------------------------------------------------------------

This is done in \lpsrToLilypond{}.

There is only one visit of \class{msrHarmony} instances in \lpsrToLilypond{lpsr2lilypondTranslator.cpp}. The \lily\ code is generated only if the harmony belongs to a voice: this is where \denorm\ ends in the workflow:%%%JMI
\begin{lstlisting}[language=CPlusPlus]
void lpsr2lilypondTranslator::visitStart (S_msrHarmony& elt)
{
#ifdef TRACING_IS_ENABLED
  {
    Bool
      traceMsrVisitors =
        gGlobalMsrOahGroup->
          getTraceMsrVisitors (),
      generateMsrVisitingInformation =
        gGlobalLpsr2lilypondOahGroup->
          getGenerateMsrVisitingInformation ();

    if (traceMsrVisitors || generateMsrVisitingInformation) {
      std::stringstream s;

      s <<
        "% --> Start visiting msrHarmony '" <<
        elt->asString () <<
        "'" <<
        ", fOnGoingNotesStack.size () = " <<
        fOnGoingNotesStack.size () <<
        ", fOnGoingChord = " <<
        fOnGoingChord <<
        ", fOnGoingHarmoniesVoice = " <<
        fOnGoingHarmoniesVoice <<
        ", line " << elt->getInputLineNumber () <<
        std::endl;

      if (traceMsrVisitors) {
        gLogStream << s.str ();
      }

      if (generateMsrVisitingInformation) {
        fLilypondCodeStream << s.str ();
      }
    }
  }
#endif

  if (fOnGoingNotesStack.size () > 0) {
  /* JMI
#ifdef TRACING_IS_ENABLED
    if (gGlobalTracingOahGroup->getTraceHarmonies ()) {
      fLilypondCodeStream <<
        "%{ fOnGoingNotesStack.size () S_msrHarmony JMI " <<
        elt->asString () <<
        " %}" <<
        std::endl;
    }
#endif
*/
  }

  else if (fOnGoingChord) { // JMI
  }

  else if (fOnGoingHarmoniesVoice) {
    // actual LilyPond code generation
    fLilypondCodeStream <<
      harmonyAsLilypondString (elt) <<
      ' ';

    // generate the input line number as comment if relevant
    if (
      gGlobalLpsr2lilypondOahGroup->getInputLineNumbers ()
        ||
      gGlobalLpsr2lilypondOahGroup->getGenerateMeasurePositions ()
    ) {
      generateInputLineNumberAndOrMeasurePositionAsAComment (
        elt);
    }
  }
}
\end{lstlisting}

